engineering @ SP   ET1010 / ET0884 MICROCONTROLLER                                   School of Electrical & Electronic Engineering APPLICATIONS (Version 19)     Engineering @ SP   TheSingaporePolytechnic’sMissionAs a polytechnic for all ages we prepare our learners to be life ready, work ready, world ready for the transformation of Singapore TheSingaporePolytechnic’sVisionInspired Learner
Serve with Mastery
Caring Community
A caring community of inspired learners committed to serve with mastery.        Self-Discipline  Personal Integrity  Care & Concern  Openness  Responsibility  Excellence  TheSPCOREValuesForanyqueriesonthenotes,pleasecontact:Name: Mr
Christopher Sherman IsaRoom: T1041Email:Isa_Christopher_Sherman@sp.edu.sg Tel:6870 6053  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Table of Contents 1 2 3 Introduction to Microcontrollers .................................................................................................
What is a microcontroller? ..............................................................................................................
Main parts of a microcontroller ......................................................................................................
How is a microcontroller different from a microprocessor? ............................................................
Common characteristics of a microcontroller ...............................................................................
11 1.5  Typical applications of a microcontroller ......................................................................................
11 1.6  Embedded systems ........................................................................................................................
12 1.7  A simple application: Pedestrian crossing traffic light control ......................................................
12 1.8  Microcontroller Development Tools ..............................................................................................
14 1.9  Software Build Process ..................................................................................................................
15 Summary ..................................................................................................................................
15 1.10 1.11 Review questions ......................................................................................................................
16 An Overview of the Microchip PIC 18F4550 Microcontroller .......................................................
17 2.1  Why Microchip’s PIC18F4550? ......................................................................................................
17 2.2  Key features of PIC18F4550...........................................................................................................
17 2.3  PIC18F4550 Variants .....................................................................................................................
18 2.4  Block diagram & on-chip peripherals ............................................................................................
20 2.5  Pin diagram ...................................................................................................................................
21 2.6  A basic PIC-based circuit ................................................................................................................
22 2.7  A simple application – “zebra crossing light control” ....................................................................
23 2.8  Review Questions ..........................................................................................................................
27 I/O Ports and Device Interfacing ................................................................................................
28 IO Interfacing.................................................................................................................................
28 3.1 Interfacing to LED bar ...................................................................................................................
29 3.2 Interfacing to 7 Segment Display ..................................................................................................
30 3.3 Interfacing to multi-digit 7-segment display .................................................................................
31 3.4 Interfacing to Matrix Keypad ........................................................................................................
35 3.5 Interfacing to LCD ..........................................................................................................................
37 3.6 3.7  Using a transistor as a switch .......................................................................................................
38 3.8 Interfacing to DC motor / solenoid ................................................................................................
39 3.9  PIC18F4550 I/O ports ....................................................................................................................
41 Port A ........................................................................................................................................
42 3.10  ET1010 / ET0884 – Microcontroller Applications   Page 4 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Configuring a GPIO pin as an Input or Output pin ....................................................................
44 3.11 Connecting an LED as output and a switch as input .................................................................
45 3.12 3.13 Reading from Digital Input pins ................................................................................................
46 3.14  Writing to Digital Output Pins ..................................................................................................
47 Other I/O ports B to E ...............................................................................................................
47 3.15 3.16 Review Questions .....................................................................................................................
49 4 Analogue to Digital Converter ....................................................................................................
51 4.1 Introduction to A/D Converter .......................................................................................................
51 4.2  Examples of application ................................................................................................................
52 4.2.1  Measuring temperature using a digital thermometer .........................................................
52 4.2.2  Measuring brightness using a light dependent resistor ......................................................
52 4.3  A/D conversion in PIC18F4550 – sample calculations ...................................................................
54 4.4  The structure of PIC18F4550’s A/D converter module ..................................................................
57 4.5  Registers associated with A/D operation ......................................................................................
58 ADCON0 ...............................................................................................................................
58 ADCON1 ...............................................................................................................................
60 ADCON2 ...............................................................................................................................
62 4.6  The complete A/D operation sequence .........................................................................................
65 4.7  ADC Programming example ..........................................................................................................
66 4.8  Review Questions ..........................................................................................................................
67 4.5.1 4.5.2 4.5.3 5 A brief revision on C programming language ..............................................................................
68 5.3 5.4 5.5 5.5.1 5.5.2 5.2.1 5.2.2 C language fundamentals – #define & #include directives, comments, constants, 5.1 variables, operators .............................................................................................................................
68 5.2  Pre-Processor Directives ................................................................................................................
68 #define Directive .................................................................................................................
68 #include Directive ................................................................................................................
68 Code Comments ....................................................................................................................
69 Constants ................................................................................................................................
69 Variables .................................................................................................................................
70 Local variables .....................................................................................................................
71 Global variables ...................................................................................................................
71 5.6 Operators ................................................................................................................................
72 5.7  Arithmetic operators .....................................................................................................................
72 5.8  Relational operators ......................................................................................................................
72 Compare two values and return 1 (for true) or 0 (for false) based on the comparison ......................
72 5.9 Logical operators ...........................................................................................................................
73 5.10 Bitwise operators ......................................................................................................................
73 5.11  C language fundamentals – functions & program control statements ............................
74  ET1010 / ET0884 – Microcontroller Applications   Page 5 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  5.11.1 5.12.1 5.12.2 5.12.3 5.12.4 Functions .........................................................................................................................
74 Program control statements .................................................................................................
75 Conditional “if-else” ........................................................................................................
75 Conditional “Switch Case” ..............................................................................................
76 Iterative “for” Loops .......................................................................................................
76 Conditional “while” Loops ..............................................................................................
78 Review Questions .....................................................................................................................
79 5.12 5.13 6 7 8 6.3.1 6.3.2 6.3.3 6.3.4 PIC18F4550 Programmable Timers and Counters .......................................................................
80 6.1  Why are Timers and Counters needed in micro-controller applications? ......................................
80 6.2  Programmable timers / counters in PIC18F4550 ..........................................................................
82 6.3  Using Timer0 to schedule an event ...............................................................................................
83 Registers associated with Timer0 operation .......................................................................
83 Timer0 calculations ..............................................................................................................
86 Programming Timer0 to schedule an event ........................................................................
89 Scheduling a periodic event using Timer0 ...........................................................................
90 6.4  Using Timer0 to measure the elapsed time [Optional] .................................................................
91 6.5  Using Timer2 for PWM control of DC motor speed .......................................................................
93 Timer 2 – Introduction .........................................................................................................
93 PWM (Pulse Width Modulation) ..........................................................................................
96 PIC18F4550’s PWM capability .............................................................................................
97 6.6  Review Questions ........................................................................................................................
Interrupts ................................................................................................................................
Introduction to interrupts ............................................................................................................
PIC18F4550’s Timer0 interrupt ....................................................................................................
PIC18F4550’s INT0 external hardware interrupt .........................................................................
PIC18F4550’s other interrupt features ........................................................................................
Multiple interrupt sources .................................................................................................
Other interrupt sources .....................................................................................................
Interrupt priority ................................................................................................................
Review Questions ........................................................................................................................
Serial Communications ............................................................................................................
Basics of serial communication ...................................................................................................
Serial vs
parallel ................................................................................................................
Modulation / demodulation ..............................................................................................
Synchronous vs
asynch .....................................................................................................
ronous ................................................................................................................................
Simplex, half-duplex and full-duplex .................................................................................
Serial communication protocol .........................................................................................
RS232 interfacing standards ..............................................................................................
PIC18F4550 connection to RS232 ................................................................................................
The registers associated with serial port operations ...................................................................
SPBRG – setting up the baud rate ......................................................................................
ET1010 / ET0884 – Microcontroller Applications   Page 6 of 140 Singapore Polytechnic Microcontroller Applications - ET1010 / ET0884 ____________________________________________________________________ 8.3.28.3.38.3.48.3.58.3.68.3.78.3.8TXREG–Writingdatatobetransmitted............................................................................122RCREG–retrievingdatareceived.......................................................................................122TXSTA–transmitstatusandcontrol..................................................................................122RCSTA–receivestatusandcontrol....................................................................................125PIR1–peripheralinterruptrequest(flag)register1..........................................................126ProgrammingthePIC18toreceivedataserially................................................................128ProgrammingthePIC18totransmit&receivedataserially..............................................1298.4 ReviewQuestions.........................................................................................................................13099.2.19.2.2IntroductiontoMicro‐controllerIndustryApplications..............................................................1319.1Introduction..................................................................................................................................1319.2 MicrocontrollerApplicationsinIndustry......................................................................................132AutomotiveIndustry...........................................................................................................132DistributedEmbeddedSystem...........................................................................................1329.3 SingleECUEmbeddedSystem......................................................................................................133InternetofThings–IoT................................................................................................................1349.4CoffeeMachine..................................................................................................................134TraceTogetherToken.........................................................................................................135LowPowerManagement.............................................................................................................1359.5.1 MicrocontrollerPowerModes...........................................................................................1369.6 MicrocontrollerFeaturesinIndustryApplications.......................................................................137RealTimeOperatingSystem(RTOS)...................................................................................1379.7 CyberSecurity...............................................................................................................................1389.8 MulticoreMicrocontrollers...........................................................................................................139Amdahl’sLaw......................................................................................................................1399.9 Summary......................................................................................................................................1409.6.19.4.19.4.29.59.8.1Tutorial 1—8Lab Sheets          Lab 1 – Intro
to PIC18F4550 Board, MPLAB-IDE, C-compiler & USB downloaderLab 2 – Interfacing to switches and LED’sLab 3 – Interfacing to 7-segment displays and buzzerLab 4 – Interfacing to keypad and LCDLab 5 – Analogue to digital converter and interfacing high power devicesLab 6 – Programmable timer and PWM (Pulse Width Modulation)Lab 7 – Interrupt programmingSchematics – MCT Board, General IO Board, LCD / Keypad Board,         7-Segment / Switch BoardC-D-I-O Project SpecificationsET1010 / ET0884 – Microcontroller Applications Page 7 of 140 Introduction to Microcontrollers  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 1  1.1  What is a microcontroller?  A microcontroller (MCU or µC) is a small computer on a single integrated circuit (IC) consisting internally of a relatively simple CPU, clock, timers, I/O ports and memory (program memory in the form of flash, and a small amount of data memory in the form of RAM)
Microcontrollers are designed for small or dedicated applications.  Thus, in contrast to the micro-processor used in personal computers (PC) and other high-performance or general purpose applications, simplicity is emphasized in microcontrollers.  Some microcontrollers may use four-bit words and operate at clock rate as low as 4 kHz, as this is adequate for many typical applications, enabling low power current consumption in the micro Ampere range
They will generally have the ability to retain functionality while waiting for an event such as a button press or other interrupt; power consumption while sleeping (CPU clock and most peripherals off) may just be nanowatts, making many of them well suited for long lasting battery applications.  Other microcontrollers may serve performance-critical roles, where they may need to act more like a digital signal processor (DSP), with higher clock speeds and power consumption
Microcontrollers are used in automatically controlled products and devices, such as automobile engine control systems, implantable medical devices, remote controls, office machines, appliances, power tools and toys.   By reducing the size and cost compared to a design that uses a separate micro-processor, memory, and input/output devices, microcontrollers make it economical to digitally control even more devices and processes.  Mixed signal microcontrollers are common, integrating analogue components needed to control non-digital electronic systems.                    ET1010 / ET0884 – Microcontroller Applications    Page 8 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________   1.2  Main parts of a microcontroller  Basic building blocks of a microcontroller is shown in Figure 1.1.  CPU = ALU + Control + Registers Clock Timers Memory I / O ports  Figure 1.1 Main parts of a microcontroller  The  memory  holds  the  instructions  or  data.  The  memory  is  typically  RAM  (random access  memory  –  which  is  volatile  i.e.  data  is  lost  when  power  is  turned  off)  and  /  or FLASH (a type of EEPROM – non-volatile, and can be block erased)  The I/O ports allow interactions with the outside world.  The CPU has logic that fetches instruction and data, executes the instruction and stores the result back to memory.  1.3  How is a microcontroller different from a microprocessor?  A  microprocessor  often  requires  other  components  to  form  a  functional  system  for instance an external clock source using a crystal oscillator, peripheral devices such as timers, and memory as shown in Figure 1.2
On the other hand, for a microcontroller all these peripherals are built in albeit in smaller in size and lower in cost.  Microprocessors  are  typically  used  in  personal  computers  (PC)  which  are  general purpose  systems.  Various  programs  running  on  them  such  as  operating  system,  web browser, email software, word processor, spreadsheet, games makes them flexible to be used  for  a  variety  of  purposes.  On  the  other  hand,  microcontrollers  are  often  used  in dedicated  systems  designed  for  one  task  only  such  as  a  microwave  oven  or  a  coffee machine
The Figure 1.3 shows a desktop PC (Personal Computer) with the monitor as output and the keyboard and mouse as input units
A motherboard inside the PC hosts a  ET1010 / ET0884 – Microcontroller Applications   Page 9 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  processing unit, some peripheral devices (e.g
memory, timer) and connections for the various  inputs  and  outputs.  A  processor,  or  Central  processing  Unit  (CPU),  is  a  logic circuitry that reacts and processes instructions to perform computation.   Most  CPUs  used  in  computers  today  are  multicore  processors,  which  means  that  the integrated circuitry comprises multiple processors to improve performance and support simultaneous processing of several computer tasks
Consequently, a multicore CPU is more powerful as compared to a single core CPU
On the other hand, a microprocessor is essentially a single-chip implementation of a CPU.   A microprocessor contains all of a CPU's functions and can perform arithmetic and logic operations  with  registers.  The  differences  between  CPU  and  microprocessors  rather vague  due  to  their  similarities.  In  computer  literature  terms  CPU  and  microprocessor often used interchangeably.  A microcontroller A microprocessor  CPU = ALU + Control + Registers Clock Timers Memory  CPU = ALU + Control + Registers I / O ports Clock Timers etc Memory I / O ports Figure 1.2 Microcontroller vs
microprocessor               ET1010 / ET0884 – Microcontroller Applications   Page 10 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Connections for other I/O peripherals  Mother board inside the PC Monitor Peripheral devices Keyboard  Mouse Microprocessor         Figure 1.3 Microprocessor as part of a personal computer  1.4  Common characteristics of a microcontroller  Microcontrollers share the following characteristics:   •  Microcontrollers  are  embedded  inside  some  other  device  (often  a  consumer product) so that they can control the features or actions of the product
Therefore, another popular name for a microcontroller is embedded controller. •  Microcontrollers  are  dedicated  to  one  task  and  run  one  specific  program.  The program is stored in non-volatile memory (e.g
ROM / flash) and generally does not change. •  Microcontrollers are often low-power devices
A desktop PC might consume 50 watts  of  electricity  but  a  battery-operated  microcontroller  might  consume  50 milliwatts. •  A microcontroller works with fixed input and output devices
It reads the status of the input devices and sends control signals to the output devices
For example, a microwave oven controller takes input from a keypad, displays output on an LCD display and controls a relay that turns the microwave generator on and off. •  A  microcontroller  is  often  small  and  low  cost.  The  components  are  chosen  to minimize size and to be as inexpensive as possible.  1.5  Typical applications of a microcontroller  Microcontrollers are found in almost all smart electronic devices
From microwave ovens to automotive braking systems, they are around us doing jobs that make our lives more convenient and  safer
Typically,  a microcontroller  receives  inputs  from  sensors  (e.g.  a temperature  sensor),  makes  some  intelligent  decisions  (e.g.  is  the  temperature  too high?), and then drives some outputs / mechanism to cause something to happen (e.g
turn on a fan).  ET1010 / ET0884 – Microcontroller Applications   Page 11 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________   Let’s consider design of an intruder alert device to protect a home against intruders while the owner is away
Before leaving home, owner can activate the device by pressing a button
He must then leave within a minute
Upon returning home, he opens the door and triggers a motion sensor, the gadget will prompt him to key in the correct password within 30 seconds, failing which an alarm will be activated.   Based on the description of the device above, the following input / output devices are likely  to  be  used:  some  buttons,  some  LED’s,  a  motion  sensor,  an  LCD,  a  keypad,  a buzzer
This can change based on the design and fabrication constrains
Embedded systems  An embedded system is a computer system designed to perform one or a few dedicated functions,  often  with  real-time  computing  constraints  i.e.  the  system  must  respond  in time to external stimuli
The system often includes hardware and mechanical parts
By contrast, a general-purpose computer, such as a PC, is designed to be flexible and to meet a wide range of end-user needs.  Embedded systems are controlled by a microcontroller or in some specific applications using  a  digital  signal  processor  (DSP).  Since  an  embedded  system  is  dedicated  to handle a particular task, design engineers can optimize it reducing the size and cost of the  product  and  increasing  the  reliability  and  performance.  Physically,  embedded systems  range  from  portable  devices  such  as  MP3  players,  to  large  stationary installations like traffic lights.  1.7  A simple application: Pedestrian crossing traffic light control  A pedestrian crossing is shown in Figure 1.4
A micro-controlled based embedded system is required to control the traffic and pedestrian lights.                Red man Green man Red  Amber  Green   Pedestrian Lights Count Down Display Buzzer Push b tt Traffic Lights Figure 1.4 Pedestrian crossing traffic light control    ET1010 / ET0884 – Microcontroller Applications   Page 12 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  From the figure, we can conclude that the two push buttons are the inputs and buzzers, count down display and traffic lights are the output devices for this system
Considering these  basic  hardware  requirements,  a  block  diagram  of  the  traffic  light  control  can  be drawn as shown in Figure 1.5.           Lights, 5 bits Count down display, 14 bits Buzzers, 2 bits  2 Push buttons using 2 Digital Inputs  Microprocessor Figure 1.5 – Block diagram for traffic light control  The next step of the design is to study the flow of operations for the traffic light control system
Figure 1.6 shows an example flow chart for this scenario.                               No Begin On Green TL On Red Man Off the rest Delay Button pressed? Yes On Amber TL On Red Man Off the rest Delay On Red TL On Green Man Off the rest Set COUNT to max Delay Display COUNT Delay Decrement COUNT Beep Yes No COUNT >= 0 ? Figure 1.6 Flow chart for traffic light control    ET1010 / ET0884 – Microcontroller Applications   Page 13 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 1.8  Microcontroller Development Tools   A  microcontroller-based  electronic  system  requires  both  hardware  and  software developments concurrently
In terms of hardware development, it is necessary to first understand / select /procure suitable input/output devices (i.e
sensors / actuators) as well as a microcontroller
After that necessary electronic circuit is designed using a Computer  Aided  Design  (CAD)  tool.  CAD  tools  allow  capturing  the  schematic, performing  some  simulations,  and  then  laying  out  a  Printed  Circuit  Board  (PCB).  Developing a prototype on a bread-board, or on a strip-board, or on a PCB is done for testing the design in practice
If several sub-circuits are used, some interfacing may be required
However,  a  microcontroller  cannot  work  unless  it  is  programmed.  To  program  the microcontroller, an Integrated Development Environment (IDE) is used
A program is then written, using either a high-level language such as C-language or an assembly language
A program written in a high-level language is easier to understand, for instance, it is easier figure out what the following program lines mean:  if (temp > 30)  on_motor;             On  the  other  hand,  an  assembly  language  is  a  low  level  programming  language designed  for  a  specific  processor.  A  program  written  directly  at  microcontroller’s assembly language will look like as in the following example: BSF   MOVLW 06h   MOVWF 85h   BCF   03h, 5   03h, 5 ; go to Bank 1 ; put 00110 into W ; move 00110 into TRISA ; come back to Bank 0      The  microcontroller  cannot  understand  the  high-level  language  or  the  assemble language – it can only comprehend machine code that is a string of 1’s and 0’s (e.g
…).  On a computer, the string of 1’s and 0’s are stored as hexadecimal numbers (i.e
in a hex file).  So, the program written in high level language must be first compiled and converted into the machine code using a compiler
Likewise, the program written in assembly language  must  be  first  assembled  into  the  machine  code  using  an  assembler.  The machine  code  is  then  downloaded  (usually  via  USB  cable)  from  the  PC  into  the microcontroller memory.   As  mentioned,  a  compiler  converts  the  program  written  in  high  level  language  into machine  code  directly.  Due  to  this  convenience,  it  is  more  popular  for  software development
However, assembly language is still used for fine tuning or optimizing the  code.  Even  with  the  circuits  and  program  ready,  usually  some  trouble-shooting will be required to get a microcontroller project working properly.  ET1010 / ET0884 – Microcontroller Applications   Page 14 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 1.9  Software Build Process The Software Build Process generally refers to the sequence of steps required to finally generate a binary executable that can be flashed to the ROM of a microcontroller.  The flow chart below illustrates the build process,   Pre-Processor Compilable C Code Assembler Source files Object files Compiler Assembler Linker Executable Binaries / ELF/ABS Debug files Parses the C code to extract only compilable code from Pre-Processor directives, comments, etc
Compiles the code to generate the corresponding Assembly Code based on the instruction set for the target microcontroller Takes the Assembler Code files generated by the Compiler and generates the intermediate Object code files need for the Linker
The Linker takes all the Object files and allocates the required RAM and ROM space and then generates binary executable for debugging and also sometimes a binary format file for flashing the Microcontroller ROM     1.10 Summary  In  this  chapter,  an  introduction  to  microcontrollers  is  given.  In  the  following  chapters, essential features of microcontrollers and how to use them in practice will be explained
These  concepts  will  be  introduced  using  one  of  the  well-known  microcontroller  from industry, PIC18F4550 from Microchip, as an example
Some useful features, such as I/O ports,  input/output  device  interfacing,  analogue  to  digital  converters,  timers,  interrupts will be explained with examples.  ET1010 / ET0884 – Microcontroller Applications   Page 15 of 140   2
Look around and name several devices that you encounter in your daily life where a microcontroller may be found:  Applications of microcontroller  1.  2.  3.   Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 1.11 Review questions  1
Compare the various microcontroller characteristics above with the microprocessor inside a desktop PC
How are they different?   Microcontroller  Microprocessor    Dedicated or general purpose  Power consumption  Input and output devices  Size  Cost            3
Consider one of the devices you have listed above.   a) Draw its hardware block diagram taking into account all the inputs and outputs to the microcontroller.  b) Draw a flow charts of its operation.    4
What is the purpose of the C Pre-Processor ? List some C Code examples where the C Processor is used.         ET1010 / ET0884 – Microcontroller Applications   Page 16 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 2  An Overview of the Microchip PIC 18F4550 Microcontroller 2.1  Why Microchip’s PIC18F4550?     Among the more popular ones are AVR, ARM, etc
It is not easy to decide which micro-controller is the best for a course or for use in a project.  In this course, we have decided to use Microchip’s PIC18F4550 for a few reasons    It can be programmed by a USB cable using a pre-flashed bootloader using a desktop application to load and transfer the binary executable    The software tool IDE (Integrated Development Environment), the C-compiler, as well as the utility program to download a hex file into the micro-controller are available as “Freeware” software.       The USB connectivity, large amounts of RAM memory for buffering and Flash program memory make it ideal for embedded control and monitoring applications that require periodic connection with a PC via USB for data upload / download and/or firmware updates.   ET1010 / ET0884 – Microcontroller Applications   Page 17 of 140 The key features of PIC18F4550 include the following:  2.2  Key features of PIC18F4550    Parameter  Program Memory Type  Program Memory (KB)  CPU Speed (MIPS)  RAM Bytes  Data EEPROM (bytes)  Digital Communication Peripherals  Capture/Compare/PWM Peripherals  Timers  ADC  Comparators  USB (ch, speed, compliance)  Temperature Range (C)  Operating Voltage Range (V)  Pin Count  Value  Flash  32  12  2,048  256  1-A/E/USART, 1-MSSP(SPI/I2C)  1 CCP, 1 ECCP  1 x 8-bit, 3 x 16-bit  13 ch, 10-bit  2  1, Full Speed, USB 2.0 (12Mbits/s)  -40 to 85  2 to 5.5  40  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 2.3  PIC18F4550 Variants    The PIC18F4550 comes in different packages as show below, 28-Lead Skinny Plastic Dual In-Line (SP) – 300 mil Body [SPDIP] 40-Lead Plastic Dual In-Line (P) – 600 mil Body [PDIP]  28-Lead Plastic Small Outline (SO) – Wide, 7.50 mm Body [SOIC]   44-Lead Plastic Thin Quad Flatpack (PT) – 10x10x1 mm Body, 2.00 mm Footprint [TQFP]    44-Lead Plastic Quad Flat, No Lead Package (ML) – 8x8 mm Body [QFN]    The SPDIP & PDIP packages are more suitable for prototyping using bread-board, strip-board & thru-hole PCB.   However, SOIC, TQFP & QFN packages have a smaller footprint and helps to reduce the PCB size.   ET1010 / ET0884 – Microcontroller Applications   Page 18 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________   The table below shows different variants of the PIC18F series of microcontrollers   Features  Program Memory (Bytes)  Program Memory (Instructions) Interrupt Sources I/O Ports Capture/Compare/PWM Modules Enhanced Capture/Compare/ PWM Modules Parallel Communications (SPP) 10-Bit Analog-to-Digital Module Packages PIC18F2455  PIC18F2550  PIC18F4455  PIC18F4550 24576 32768 24576 32768 12288 16384 12288 16384 19 Ports A, B, C, (E) 2 19 Ports A, B, C, (E) 2 20 Ports A, B, C, D, E 1 20 Ports A, B, C, D, E 1 0 No 0 No 1 Yes 1 Yes 10 input channels 28-pin PDIP 28-pin SOIC 10 input channels 28-pin PDIP 28-pin SOIC 13 input channels 40-pin PDIP 44-pin TQFP 44-pin QFN 13 input channels 40-pin PDIP 44-pin TQFP 44-pin QFN You will notice that the 2550 / 4550 have more program memory compared to the 2455 / 4455
The bigger PIC’s (4455 / 4550) of course have more input/output pins.  Microchip has hundreds of different PIC’s
Check out www.microchip.com
The above 4 are featured in the same datasheet and have many things in common
Choosing a suitable PIC to use for a project / product will only come with experience
The choice often depends on features currently required, future enhancements planned for the product/gadget, prototyping / manufacturing constraints, price and availability etc
Frequently, engineers / designers look for something “good enough”, not necessarily “optimal”.                     ET1010 / ET0884 – Microcontroller Applications   Page 19 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 2.4  Block diagram & on-chip peripherals   As can be seen from the block diagram, PIC18F4550 has many on-chip peripherals
In this course we will study those that are most useful for projects e.g
I/O, ADC, Timer, Interrupt, USART.     Figure 2.1 – PIC18F4550 block diagram   ET1010 / ET0884 – Microcontroller Applications    Page 20 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 2.5  Pin diagram   Figure 2.2 – PIC18F4550 pin diagram   Most microcontroller pins can support several alternate functions.  For instance, the pin 33 is RB0 (Port B Pin 0), AN12 (analogue input 12), INT0 (external interrupt 0), FLT0, SDI and SDA, i.e
a total of 6 functions multiplexed on one pin.                  ET1010 / ET0884 – Microcontroller Applications   Page 21 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 2.6  A basic PIC-based circuit  Figure 2.3 – A basic PIC18F4550-based circuit   As you can see, a 5 volt supply & ground need to be connected to pins 11, 12, 31, 32 as shown
A 100nF capacitor is connected across 5V and ground
A 20MHz crystal together with two 22pF capacitors are connected at pins 13 & 14 to provide the clock source
This clock signal will go through a PLL (Phase Locked Loop) to generate a 48MHz clock required for USB operation
For this module, you can take Fosc as 48MHz
A simple reset circuitry (consisting of a switch and two resistors: 10kOhm & 470Ohm) at pin 1 completes the picture
Of course, more connections are usually needed, depending on the application.  For the Micro-controller board used during the practical lessons in this module, the pins 18, 23, 24, 37 are also connected so that a hex file can be downloaded to the PIC18F4550 via the USB port of a PC
Likewise, the I/O pins (RA0-5, RB0-3, 5, RC0-2, 6-7, RD0-7, RE0-2) are connected to interface to other input / output devices.               ET1010 / ET0884 – Microcontroller Applications   Page 22 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 2.7  A simple application – “zebra crossing light control”   Take a look at the more intelligent version of the Zebra Crossing Lights below
If no body presses the buttons, the lights will blink at a certain frequency (e.g
1 Hz)
If a pedestrian presses a button, the lights will blink at a higher frequency and the Buzzer will beep for the next few seconds (e.g
10 seconds)
Of course, the buttons can be replaced by suitable sensors.                                 Zebra crossing Buzzer Light Button     Figure 2.4 – “Intelligent Zebra Crossing Lights” The block diagram is shown below: Buttons 2 PIC (Microcontroller) 2 2 Lights Buzzers Figure 2.5 – Block diagram of “Intelligent Zebra Crossing Lights”       ET1010 / ET0884 – Microcontroller Applications   Page 23 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  The flowchart for the “Intelligent Zebra Crossing Lights” is shown below, Begin Is Button Pressed ? y n On Lights, Off Buzzers
Delay 0.5 s Off Lights Delay 0.5 s Set COUNT = 1 COUNT  <= 20 ? n y On Lights, On Buzzers Delay 0.2 s n Off Lights, Off Buzzers Delay 0.2 s Inc COUNT                                                   Figure 2.6 – Flowchart of “Intelligent Zebra Crossing Lights”  ET1010 / ET0884 – Microcontroller Applications   Page 24 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  You have learnt how to draw block diagram and flowchart in Chapter 1 on the System level.  The System block diagram now needs to be decomposed to electronic circuit diagrams and schematics for simple input/output devices as well, e.g
a push button as input and an LED as output
The push button below gives logic ‘0’ when pressed
Such button is said to be “Active Low”
5 V 10 k 470 Button Micro-controller input pin    Figure 2.7 – Circuit diagram for push button (active low) The micro-controller pin connected to the button must be configured as a digital input pin to read the status of the button i.e. “pressed” or “not pressed”
We will learn how to do this in the next chapter.  The circuit below is configured in Active High using a Pull-Up resistor
Button 5 V 470 10 k Micro-controller input pin    Figure 2.8 – Circuit diagram for push button (active high)                                     ET1010 / ET0884 – Microcontroller Applications   Page 25 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  The LED below lights up when logic ‘1’ is applied
Such LED is said to be “active high”
LED 470 Micro-controller output pin Figure 2.9 – Circuit diagram for LED (active high)  The micro-controller pin connected to the LED must be configured as a digital output pin to control the status of the LED i.e. “on” or “off”
Again, we will wait until the next chapter
Active Low Output circuit LED 5 V 470 Micro-controller output pin Figure 2.10 – Circuit diagram for LED (Active Low)  The buzzer below is turned on when logic ‘1’ is applied i.e
active high
Micro-controller output pin 470 Buzzer +  -  Figure 2.11 – Circuit diagram for LED (Active High)   The buzzer can also be connected as active low
Again, the micro-controller pin connected to this must be configured as a digital output pin.                                         ET1010 / ET0884 – Microcontroller Applications   Page 26 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 2.8  Review Questions  1.  What would be your key considerations in choosing a micro-controller for project?   2.  Based on the PIC18F4550 pinout diagram in Figure 2.2 in the notes, answer the  following questions  At which pins should the power supply (5 volts & ground) be connected?  At which pins should the crystal/oscillator be connected to supply the clock to the PIC?  At which pins should the reset button be connected?      3.  List what are the differences between Digital Input circuits that use Pull Up vs 4.  What are the differences between parallel communication and serial Pull Down resistors.  communication?                             ET1010 / ET0884 – Microcontroller Applications   Page 27 of 140  I/O Ports and Device Interfacing Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 3 3.1  IO Interfacing   Many I/O (input/output) devices, beside LED’s and switches, can be connected to a micro-controller
Various kinds of sensors can be connected to sense the environment
Likewise, various kinds of “actuators” can be connected to bring about some response to changes in the environment
For instance, it is hot, so switch on the fan
Microcontrollers are highly configurable and versatile devices which require external electronic circuits to interact with the physical environment
The PIC18F4550 micro-controller is a low-power device which can be interfaced directly to TTL and CMOS digital devices.   Most other devices cannot be connected directly to its I/O pins due to the mismatch of some electrical properties: (Reason #1 for “interfacing”) o  A 15V motor cannot be driven directly by the microcontroller’s Digital Output pins  o  An input device producing 12V can damage the Microcontroller’s Input pins if connected directly
Suitable components/circuits must be placed between the micro-controller pin and the high power devices
For PIC18F4550, the maximum current that can be sunk by an I/O pin is 25mA and the maximum current sunk by all ports is 200mA
The maximum current that can be sourced by an I/O pin is also 25mA and the maximum current sourced by all ports is also 200mA
5 V PIC18F4550 LED 470 output 0 to light up LED 470 output 1 to light up LED Figure 3.7 – Current sunk vs
current sourced  Maximum current that can be sourced is  LED                           Maximum current that can be sunk is 25mA    ET1010 / ET0884 – Microcontroller Applications   Page 28 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  The micro-controller also has a limited number of I/O pins
So sometimes, encoder / decoder are used, to reduce the number of pins required to interface to a device. (Reason #2 for “interfacing”) The sections below show how common I/O devices can be interfaced to a microcontroller.                     PIC18F4550  3.2  Interfacing to LED bar                     Digital output port LED bar Anode  Cathode How it looks Figure 3.8 – Bar LED   An LED bar consists of several (e.g.10) LED’s in a single package
It is useful as a “level indicator”
Above, the anodes are driven (via current limiting resistors) by the PIC output pins while the cathodes are grounded
The PIC outputs a logic ‘1’ to light up an LED
Alternative connection: the cathodes are driven by the PIC output pins while the anodes are connected to Vcc
The resistors can be individual resistors or an SIL (single in line) package.  ET1010 / ET0884 – Microcontroller Applications   Page 29 of 140 5 V 7-segment display PIC18F4550 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 3.3  Interfacing to 7 Segment Display                  Digital output port How it looks COMMON A B C G dp A G B C dp F E D      Common anode Cathodes Figure 3.9 – 7 segment display  A 7-segment display also consists of several (usually 8) LED’s in a single package
The segments are arranged into a figure of 8, and can display one decimal/hex digit. (See “multi-digit display” regarding the decimal point.) Above, the cathodes are driven (via resistors) by the PIC output pins while the anodes are tied together internally ( - a common anode device ) and connected to Vcc (externally)
The PIC outputs a logic ‘0’ to light up a segment
The C-code is TRISD = 0b 0 0 0 0 0 0 0 0 ;  // configure port D as output PORTD = 0b 1 0 0 1 0 0 1 0 ;  // display “5” on 7-segment Below, a binary to 7-segment decoder is used to reduce the number of PIC pins required
The PIC only needs to output 0 1 0 1 (binary for 5) at the decoder inputs A3-A0
The decoder will produce the correct 7-segment pattern (0 0 1 0 0 1 0) to display 5.                    ET1010 / ET0884 – Microcontroller Applications   Page 30 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________                  PIC18F4550 Digital output port BCD 7-segment 5 V RBI’ LT’ 5 16 3 7447 7-segment decoder A3 =  A2 = 1 A1 =  A0 = 1 6 2 1 7 8 13 12 11 10 9 15 14 0 1 0 0 1 0 0 1 A B C D E F G dp       7-segment display 5 V COMMON F E A G D B C dp Common anode Figure 3.10 – 7 segment display with decoder  3.4  Interfacing to multi-digit 7-segment display     To display multiple digits e.g
we need several 7-segment displays
To reduce the number of I/O pins needed, use the following method, based on “persistence of vision”, “multiplexing” & “transistors as switches”.                 PIC18F4550 Digit 2 Digit 1 Digit 0 Digital output port RD0 RD1 RD2 RD6 RD7 RB0 RB1 RB2 A B C G dp F E A G A G A G B C B C F E B C F E Common cathode D dp D dp D dp Common ground Common ground Common ground    Figure 3.11 – multi-digit 7 segment display  ET1010 / ET0884 – Microcontroller Applications   Page 31 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  In Figure 3.11, “common cathode” displays are used (i.e
a logic ‘1’ to light up a segment)
RB2=1 enables Digit2, RB1=1 enables Digit1, RB0=1 enables Digit0. (*) Transistors as switches – if a logic ‘1’ written to the control input of a transistor, that transistor will be “on” and the common cathode of the digit will be connected to ground, i.e
enabled.                                                  ET1010 / ET0884 – Microcontroller Applications   Page 32 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  The following code displays the value “1.23” on the 7 segment display while (1) // a “infinite loop” to show each digit in turn, repeatedly    {                        // enable Digit 2 and display “1 with decimal point on” on it: PORTB = 0 b 0 0 0 0 0 1 0 0; // enable Digit 2 PORTD = 0 b 1 0 0 0 0 1 1 0; // show 1
on it Delay… // introduce a brief delay  // enable Digit 1 and display “2” on it PORTB = 0 b ____________ ; // enable Digit 1 PORTD = 0 b ____________; // show 2 on it Delay… // introduce a brief delay  // enable Digit 0 and display “3” on it PORTB = 0 b 0 0 0 0 0 0 0 1; // enable Digit 0 PORTD = 0 b 0 1 0 0 1 1 1 1; // show 3 on it Delay… // introduce a brief delay  // RD7-0 are multiplexed to output the digits // one after another.    } What actually happens:    Figure 3.12 – Persistence of vision          ET1010 / ET0884 – Microcontroller Applications   Page 33 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  The “7-segment / switch board” used in the lab is shown below
Common anode 7-segments are used together with inverting drivers
The end result is that a logic ‘1’ lights up a corresponding segment
RD7-0 multiplexes out the data to be displayed while RB3-0 enables one digit at a time
Figure 3.13 – Lab’s multi-digit 7 segment display                       ET1010 / ET0884 – Microcontroller Applications   Page 34 of 140  PIC18F4550 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 3.5  Interfacing to Matrix Keypad                      Digital input port Digital output port 1 0 0 0 0 1 0 0     Figure 3.14 – Matrix keypad Matrix keypad                 A 4x4 matrix keypad consists of 16 (push button) switches arranged in a matrix
Only 8 PIC pins (4 out, 4 in) need to be connected, to know which of the 16 keys has been pressed
The scanning mechanism goes like this, a logic ‘1’ is written to only one column (e.g
right most or 4th column) and a logic ‘0’ to the rest
The rows are then read
The row that reads logic ‘1’ uniquely identifies the closed switch
If no ‘1’ is read, try the next column e.g
3rd column, etc
We assume that opened switches read ‘0’ ( – this is true if there is a weak pull-down inside the PIC )
In the lab, the keypad encoder 74C922 is used:  ET1010 / ET0884 – Microcontroller Applications   Page 35 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Figure 3.15 – Lab’s matrix keypad with encoder  It has the following truth table
X2Y1 0 0 0 1 1 X3Y1 0 0 1 0 1 X4Y1 0 0 1 1 1 X1Y2 0 1 0 0 1 X2Y2 0 1 0 1 1 X3Y2 0 1 1 0 1 Keys X1Y3 1 0 0 0 X4Y2 0 1 1 1 1 1 X2Y3 1 0 0 1 1 X3Y3 1 0 1 0 1 X4Y3 1 0 1 1 1 X1Y4 1 1 0 0 1 X2Y4 1 1 0 1 1 X3Y4 1 1 1 0 1 X4Y4 1 1 1 1 1      X1Y1 0 0 0 0 D C B A 1 DA           D (msb), C, B, A identify the key pressed
For instance, if key ‘2’ is pressed, X2, Y1 cause DCBA = 0001
The DA (data available) signal will be set to logic ‘1’, whenever a key is pressed.  The code to read the key is as follows const unsigned char lookup[] = "123F456E789DA0BC "; while (PORTBbits.RB5 == 0);  //wait for a key to be pressed: DA==1 temp = PORTB & 0x0F;  //read from encoder, mask off top 4 bits KEY = lookup [temp];  // look up table to find key pressed  ET1010 / ET0884 – Microcontroller Applications   Page 36 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 3.6  Interfacing to LCD   An alphanumeric LCD is commonly used with a micro-controller to prompt the user for inputs e.g
password or preset temperature
The numbers and alphabets can be displayed in 2 rows of say, 16 characters.             Figure 3.16 – Alphanumeric LCD display – 4-bit mode  In the “4-bit mode” above, a byte (8 bits) can be written as two nibbles (one nibble = 4 bits), one after another, via RD3-0.   Figure 3.17 – Alphanumeric LCD display – 8-bit mode    ET1010 / ET0884 – Microcontroller Applications   Page 37 of 140  Transistors have been used as switches in the multi-digit 7-segment display earlier and in the buzzer, motor, solenoid to be covered next
Suitable transistors include 2N2222
Interfacing to buzzer When the PIC outputs a logic ‘0’, the (BJT) transistor is OFF
This turns the buzzer OFF (as it is “reverse-biased”: ‘0’ -> ‘+’, Vcc -> ‘-‘)
When the PIC outputs a logic ‘1’, the transistor is ON (Vce[sat] ~0.2 volt)
This turns the buzzer ON.  PIC18F4550 Vcc Piezo Buzzer + - ‘1’ Digital output pin C B E     Figure 3.18 – Buzzer A rectangular pulse train / wave can be produced at the PIC output pin to produce a “tone”
By varying the frequency (& duty cycle) of the wave, the pitch (& loudness) of the tone can be controlled. – We will do this in the Timer topic
Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 3.7  Using a transistor as a switch   For this module, the details of how transistors work is not important, as we will be using transistors as switches only.       3.16                                ET1010 / ET0884 – Microcontroller Applications   Page 38 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 3.8  Interfacing to DC motor / solenoid      When the PIC outputs a logic ‘1’, the transistor (usually a “Darlington” – 2 transistors in cascade, for increased current) is ON
This turns the motor ON, as there is now a path for the current to flow from Vcc through the motor and the transistor, to the ground
When the PIC outputs a logic ‘0’, the motor is OFF
PIC18F4550 Shunt diode ‘1’ Digital output pin Vcc M C B E DC motor ‘1’ ‘0’ current ‘1’ closes switch ‘0’ opens switch                                 Figure 3.19 – DC Motor When the transistor is turned from ON to OFF, the shunt diode allows current to continue to flow for a short while
Otherwise, the motor circuit would be damaged
M      A rectangular wave can be produced at the PIC output pin to control the motor speed
When the duty cycle is high (*), the motor moves faster
Again, we will do this (so called Pulse Width Modulation or PWM) in the Timer topic.  Duty Cycle” is proportion of On time to the Period expressed as a percentage value.  ET1010 / ET0884 – Microcontroller Applications   Page 39 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  It is also possible to control the motor direction, by using 4 transistors arranged as a bridge.  The motor circuit can also be used for a solenoid
A solenoid is an electromagnet which when energised, can suck in (or push out) an iron bar
This is useful in electronic lock, for instance.   3.18  Driving high–power device via mechanical relay – the need for power isolation   All the devices discussed so far are “low power” devices that can share the same Vcc (5volt) with the micro-controller circuit
Sometimes, a motor / solenoid / valve etc that requires higher voltage (e.g
12 / 24 V, or even 230 V ac) must be used in a micro-controller application
In such cases, a separate power source can be used for the high power device and a mechanical relay used to isolate it from the low power circuitry, as follows
When the transistor is on and the relay energised, the switch for the high power device will be closed.  24 V (e.g.) Vcc High power  Shunt diode relay PIC18F4550                                  ‘1’ Digital output pin B C E ground for low power side 5V circuitry     ground for high power side 24V circuitry Figure 3.20 – Mechanical relay for power isolation  ET1010 / ET0884 – Microcontroller Applications   Page 40 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 3.9  PIC18F4550 I/O ports     Why are I/O ports required? The micro-controller is an intelligent device
For it to be really useful, it must be able to monitor the status of some input devices e.g
sensors and to control some output devices e.g
actuators
In the figure below, the micro-controller monitors the temperature of a laptop
If the temperature exceeds a preset threshold e.g
30 deg Celsius, the fan will be switched on
Temperature sensor Micro-controller Fan   Figure 3.1 – Micro-controller + input + output Lab-top cooler Examine the PIC18F4550 pin diagram below
Can you see where the Port A pins are? How many are there? How are they numbered?   PIC18F4550 has 5 I/O ports: Ports A to E.             Port A Figure 3.2 – PIC18F4550 I/O ports        ET1010 / ET0884 – Microcontroller Applications   Page 41 of 140   3.10 Port A   On the micro-controller board you are using in the lab, the available Port A pins are RA5-0
Pin 14 (RA6) is connected to the oscillator, so RA6 is not available.           Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Many pins are multiplexed with alternate functions from the peripheral features, e.g
RA0 is also AN0 i.e
an analogue input
Likewise, RA1, RA2, RA3 & RA5 can be AN1, AN2, AN3 & AN4 respectively
In general, when a peripheral is enabled, that pin may not be used as a general purpose I/O pin
Figure 3.3 – General purpose I/O pins available on the micro-controller board  Upon power on reset, RA5 and RA3-0 are configured as analogue inputs and RA4 is configured as a digital input
To turn Port A into a digital I/O port, use the C-language command below
How this works is explained on the next page (no need to know the explanation in details).   ADCON1 = 0x0F; or ADCON1 = 0b00001111;  ET1010 / ET0884 – Microcontroller Applications   Page 42 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________     Figure 3.4 – Making Port A a digital I/O port by ADCON1 = 0x0F   The detailed explanation of the Analog to Digital Converter will be explained in the next chapter.                        ET1010 / ET0884 – Microcontroller Applications   Page 43 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 3.11 Configuring a GPIO pin as an Input or Output pin     The registers associated with Port A are TRISA and PORTA
TRISA is the “data direction register” for Port A
Port A is a 7-bit wide bidirectional port
Setting a TRISA bit ( = 1 ) will make the corresponding PORTA pin an input
Clearing a TRISA bit ( = 0 ) will make the corresponding PORTA pin an output
For instance: 7     TRISA PORTA  6 0   5 0                   Outputs 4 0    3 1   2 1   1 1   0 1    Inputs RA6 RA5 RA4 RA3 RA2 RA1 RA0               PORTA TRISA               Figure 3.5 – Configuring Port A pins as inputs / outputs using TRISA  In the figure above, the C-language command TRISA = 0x0F or TRISA = 0b00001111 is used to make RA6-4 output pins and RA3-0 input pins
Note: TRISA bit 7 is unimplemented so it doesn’t matter what is written to that bit
An easy way to remember this is ‘0’ (zero) looks like ‘O’ (in Output) while ‘1’ (one) looks like ‘I’ (in Input).    7  RA6  Input RA5  RA4  RA3  Input Output  Output RA2  Input RA1  Input RA0  Input 6  5  4  3  2  1  0  Upon reset, TRISA = 0b - 1 1 1 1 1 1 1, i.e
PORTA is an input port by default.  ET1010 / ET0884 – Microcontroller Applications   Page 44 of 140  5 V Micro-controller 470 RA0 RA1 LED 470 Switch 10 k Figure 3.6 – LED as output and switch as input    Based on the circuit above, RA1 is connected to the LED circuit as an Output pin   RA0 is connected to the switch circuit as an Input pin  Therefore the register TRISA needs to be written with the value 0b00000001 with bit 0 set to 1 and bit 1 set to 0 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 3.12 Connecting an LED as output and a switch as input   The circuit diagram below shows how an LED can be connected as an output and a switch as an input
Find out why the two 470-ohm resistors are required.                                         ET1010 / ET0884 – Microcontroller Applications   Page 45 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 3.13 Reading from Digital Input pins     It can be seen from the diagram that the switch is “active high” i.e
closed switch = logic ‘1’, while opened switch = logic ‘0’
How can the micro-controller know if the switch is closed or open? The C-language command to read the switch status is if ( PORTAbits.RA0 == 1 )  // if switch closed  …. // do something  An more portable alternative to read input pin values using standard C bitmask operations is show below if ( ( PORTA & 0b00000001 ) == ( 0b00000001 ) )   // if switch closed  …. // do something                                         ET1010 / ET0884 – Microcontroller Applications   Page 46 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 3.14 Writing to Digital Output Pins   The PIC specific C code to write to set a single output pin Port A Pin 1 to logic High is shown in the example below PORTAbits.RA1 = 1;    However a more portable method that can be used on most microcontrollers is to use standard C bit masking operations as shown in the example code below PORTA = PORTA | 0x01;  PORTA = PORTA & 0xFE // Set Port A Pin 1 to Logic High // Set Port A Pin 1 to Logic Low   3.15 Other I/O ports B to E   As Port A has already been discussed in details, the description below for the other ports will be brief.     Port B           Port C         Port B is a 8-bit wide bidirectional port
TRISB is the “data directional register” for PORTB
Remember ‘1’ = Input, ‘0’ = Output
Examine the PIC18F4550 pin diagram (in Figure 3.2) again
Where are the 8 Port B pins RB7-0? What other peripherals use these pins? Upon power on reset, RB7-0 are configured as digital inputs
On the micro-controller board (see Figure 3.3), the available Port B pins are RB7-5 and RB3-0
Pin 37 (RB4) is connected to an active low switch, so RB4 is not available
Port C is a 7-bit wide bidirectional port
RC3 pin is not implemented
TRISC is the “data directional register” for Port C
However, RC4 and RC5 do not have TRISC bits associated with them – they can only function as digital inputs
Port C is primarily multiplexed with the serial communication modules – e.g
the USB module
Upon power on reset, RC7-4, RC2-0 are configured as digital inputs
On the micro-controller board (see Figure 3.3), the available Port C pins are RC7-6 and RC2-0
Pin 24 (RC5) and Pin 23 (RC4) are used for USB downloading of hex file into the micro-controller, so RC5-4 are not available.  ET1010 / ET0884 – Microcontroller Applications   Page 47 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Port D           Port E            Port D is a 8-bit wide bidirectional port
TRISD is the “data directional register” for Port D
Port D is multiplexed with the Enhanced CCP module and the Streaming Parallel Port (SPP)
Upon power on reset, RD7-0 are configured as digital inputs
On the micro-controller board (see Figure 3.3), the Port D pins RD7-0 are all available
Port E is a 4-bit bidirectional wide port
TRISE is the “data directional register” for Port E
However, RE3 does not have TRISE bit associated with it – it can only function as input
Similar to other ports, Port E is multiplexed with other functions
Upon power on reset, RE2-0 are configured as analogue inputs, while RE3 is configured as a digital input (RE3 is only available if Master Clear (/MCLR) functionality is disabled)
To turn Port E into a digital I/O port, use the C-language command below.  ADCON1 = 0x0F;   // there are other possibilities On the micro-controller board (see Figure 3.3), the available Port E pins are RE2-0
Pin 1 (RE3) is used as the active low Master Clear (/MCLR) input, so RE3 is not available.  ET1010 / ET0884 – Microcontroller Applications   Page 48 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 3.16 Review Questions   1.  State the purpose of the following sensors  Sensor LDR PIR Tilt switch Ultrasonic ranger Purpose      Study the Figure 3.7 below below and fill in the blanks to describe how the I/O ports are used as digital inputs / outputs.    Figure 3.7 – Monitoring status of switches, using LEDs    a.  Which microcontroller pins are connected to inputs and outputs? b.  Write the C code required to configure the pins as digital inputs.   ET1010 / ET0884 – Microcontroller Applications   Page 49 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  c.  What is the logic level read by the microcontroller when the switch is closed and d.  Write the C code required to turn ON the LEDS connected to pins RD0, RD1 and 2.  In an Active High output circuit, a logic ‘1’ is written to the output pin will set the opened?  RD2.  LED to turn ON or OFF?   3.  If the micro-controller outputs 5V at a pin and the LED drops 1.8V and the current-limiting resistor used is 470 ohms, calculate the current in the LED.  4.  The short program below shows how the LED’s can be used to indicate the status of the switches, i.e
a closed switch lights up the corresponding LED.   Fill in the comments to explain the blank comments to explain the lines of code below      #include …    // other lines of code before main........     main()    {    // configure Port B as digital input and Port D as digital output    // TRISB = 0xFF; -- is not necessary as, upon reset, Port B is input    TRISD = ______; // upon reset RD7-0 are digital inputs – so make them outputs     while (1) // continuously monitor       {       // alternative #1:        if (PORTBbits.RB0 == 0)      //__________________________________          PORTDbits.RD0 = 1;        // __________________________________       else             // __________________________________          PORTDbits.RD0 = 0;       // __________________________________        if (PORTBbits.RB1 == 0)          PORTDbits.RD1 = 1;       else          PORTDbits.RD1 = 0;        if (PORTBbits.RB2 == 0)          PORTDbits.RD2 = 1;       else          PORTDbits.RD2 = 0;        // alternative #2:       // PORTD = ~PORTB; --- copy “complemented” PORTB to PORTD        Delay… // introduce some delay before checking switch status again       } // while    } // main   ET1010 / ET0884 – Microcontroller Applications   Page 50 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 4  Analogue to Digital Converter 4.1  Introduction to A/D Converter     Why are A/D & D/A converters required in a micro-controller application? Although a micro-controller can process data at high speed & accuracy (repeatedly without complaining!), it can only work with digital data
But, the outside world is analogue
All the physical quantities that matters – temperature, pressure, humidity, light intensity etc are analogue
A transducer is a device that converts a physical quantity e.g
length, weight, brightness, loudness into an electrical quantity – voltage or current – which is still analogue in nature
An A/D (analogue to digital) converter converts an analogue signal (e.g
) to a corresponding digital number (e.g
= 10100110102), a D/A (digital to analogue) converter does the reverse
As can be seen in the dashed box below, the PIC18F4550 has a built-in A/D converter module
If analogue output is to be produced, a D/A converter is still required
PIC18F4550 A/D converter 101101011   1   Micro-controller D/A converter analogue info. (voltage) 0011010101 di it l i f  Figure 4.1 – Analogue world, digital controller               transducer    physical quantity  e.g
temperature            signal (voltage) analogue electrical  ET1010 / ET0884 – Microcontroller Applications   Page 51 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 4.2  Examples of application  4.2.1  Measuring temperature using a digital thermometer   In a digital thermometer, a pair of wires (made of dissimilar alloys) produces a milli-volt output corresponding to the temperature being measured
This output is amplified and then A/D converted for display on the LCD
Nickel-Chromium Temp in deg Celsius Milli-volts amplifier Nickel-Aluminium Figure 4.2 – Digital thermometer   PIC with built in A/D converter LCD                4.2.2  Measuring brightness using a light dependent resistor   The resistance of an LDR (Light Dependent Resistor) depends on the ambience brightness
By using it in a “potential divider circuit”, a voltage output corresponding to the brightness can be produced
This can be A/D converted by the micro-controller and then used to make intelligent decision
For instance, if it is dark, switch on the lights (on the overhead bridge) automatically
The darker it is, the more lights will be switched on.  ET1010 / ET0884 – Microcontroller Applications   Page 52 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Figure 4.3 – Measuring brightness using LDR                   ET1010 / ET0884 – Microcontroller Applications   Page 53 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 4.3  A/D conversion in PIC18F4550 – sample calculations     First, during “acquisition time”, the analogue voltage input (Va) is “sampled & held” – imagine the switch is closed (and later opened) to make (& freeze) an exact copy of Va (as Vin)
After acquisition, Vin will remain unchanged even though Va continues to vary
There are 2 main steps in the A/D conversion.                                 acquire conversion clock Va Analogue voltage input Sample & hold Vin Copy of analogue voltage input A/D converter Digital result Vref+  Vref-    Digital result =   Vref+ -  Vref- Vin  –  Vref-      X [ 210- 1 ]     Figure 4.4 – Sample and hold and A/D conversion formula Next, during “A/D conversion”, the sampled input Vin is converted to its 10-bit digital equivalent, using the formula given
Vref+ and Vref-  are the reference voltages
For simplicity, assume that Vref+ = Vcc i.e
5V and Vref- = Vss i.e
ground or 0V
If Vin = 3.25V, the digital result = Vin – 0V  5V – 0V        3.25V        5V    x [ 210 – 1 ]   =      x 1023   =   66510   =   10100110012 If Vin < Vref- , the conversion result would be Vref- .  Likewise, if Vin > Vref+ , the conversion result would be Vref+ .  ET1010 / ET0884 – Microcontroller Applications   Page 54 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Quantization error (Optional)   In a 10-bit A/D converter, there are only 210 = 1024 different digital levels (0 – 1023)
When an analogue input is digitized, because of the finite number of digital levels, the difference between the actual analogue value and the digital representation is called the quantization error
If the reference voltages used are 5V and ground i.e
an input range of 5V, the maximum quantization error is 5V / 1023 / 2 = 2.44 mV
To see why this is the case, consider a simpler case – a 4-bit A/D converter with an input voltage range of 0-3V
The truth table follows: Analogue Input Volts 0 0.2 0.4 0.6 0.8 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 Digital Representation D3 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 D2 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 D1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 D0 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 Figure 4.5 – A/D converter with 0-3V input and 4-bit result                     The  “step  size”  is  3V  /  (24-1)  =  0.2V  i.e.  every  0.2  volt  increase  in  the  input voltage results in the binary result increasing by 1
So,  0V  is  represented  as  00002  while  0.2V  is  represented  as  00012.  However, 0.0999V is still represented as 00002
Hence the biggest quantization error is half the “step size”
And an A/D with more bits will be more accurate.  ET1010 / ET0884 – Microcontroller Applications   Page 55 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Digital output 0 – 0.1 V digitised as 0000 0.1 – 0.3 V digitised as 0001 0.3 – 0.5 V digitised as 0010 etc  2.7 – 2.9 V digitised as 1110 2.9 – 3 V digitised as 1111 Figure 4.6 – Quantization in A/D converter Analogue input 0V 0.2V 0.2V 3V 1 1 1  0010 0001 0000                                                  ET1010 / ET0884 – Microcontroller Applications   Page 56 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 4.4  The structure of PIC18F4550’s A/D converter module   The PIC18F4550’s A/D converter module has 13 input channels (for the 40-pin devices)
At any one time, only one channel can be selected for conversion
And a micro-controller application seldom requires all 13 inputs to be used – the unused pins can be configured as digital I/O pins
This module allows conversion of an analogue input to a corresponding 10-bit digital number
Figure 4.7 – Structure of PIC18F4550’s A/D converter   The user is allowed many choices e.g
which analogue input pin to use, what reference voltages (VREF+ & VREF-) to use,  how much time to sample the analogue input, which clock source to use for the A/D conversion etc.             ET1010 / ET0884 – Microcontroller Applications   Page 57 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 4.5  Registers associated with A/D operation    The PIC18F4550’s A/D converter module has five registers:  o  A/D Result High Register (ADRESH) o  A/D Result Low Register (ADRESL) o  A/D Control Register 0 (ADCON0) o  A/D Control Register 1 (ADCON1) o  A/D Control Register 2 (ADCON2) How these registers are used in the A/D conversion will be described below.      4.5.1  ADCON0    The ADCON0 register controls the operation of the A/D module.    Figure 4.8 – ADCON0   ET1010 / ET0884 – Microcontroller Applications   Page 58 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  CHS3:CHS0 select the analogue channel.  For instance, on the “General I/O Board” used in the lab, a variable resistor is connected to RA0 (Port A Pin 0 – also pin 2 or AN0)
To use AN0 to read this analogue input (which can vary continuously from 0 to 5 volts), set CHS3:CHS0 = 0000
Figure 4.9 – Variable resistor connected to RA0/AN0  Setting ADON = 1 enables the A/D converter module
C code: ADCON0bits.ADON = 1; Setting GO = 1 (with ADON set) starts the A/D conversion
C code: ADCON0bits.GO = 1; The same bit (GO/ DONE ) becoming 0 indicates that the A/D conversion is complete.                               ET1010 / ET0884 – Microcontroller Applications   Page 59 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 4.5.2  ADCON1   The ADCON1 register configures the voltage references and the functions of the port pins.        Figure 4.10 – ADCON1 VCFG1:VCFG0 configures the voltage reference.  ET1010 / ET0884 – Microcontroller Applications   Page 60 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  If both bits are cleared, the VREF+ = VDD i.e
5 V while VREF- = VSS i.e
0 V
C code: ADCON1bits.VCFG1 = 0; ADCON1bits.VCFG0 = 0; As can be seen above, these reference voltages (VREF+ & VREF-) could also come from the pins AN3 and AN2
PCFG3:PCGF0 divide the I/O pins between analogue and digital usage
The table below (or the PIC18F4550’s pin diagram in Chapter 2) shows 13 (possible) analogue input pins
33 AN12 37 AN11 34 AN10 35 36 AN9  AN8  AN7  AN6  AN5  AN4  AN3  AN2  AN1  AN0 10 2 9 8 7 5 4 3 RB0  RB4  RB1  RB3  RB2  RE2  RE1  RE0  RA5  RA3  RA2  RA1  RA0 D A D D D D D D D D D D D Figure 4.11 – Analogue or digital I/O pins   Setting PCFG3:PCGF0 = 1110 configures pin 2 (AN0) as an analogue input and the rest as digital inputs
C code: ADCON1bits.PCFG3 = 1; ADCON1bits.PCFG2 = 1; ADCON1bits.PCFG1 = 1; ADCON1bits.PCFG0 = 0; As can be seen in the diagram on the previous page, if only two analogue inputs are required, AN0 and AN1 can be selected
If only three analogue inputs are required, AN0, AN1 and AN2 can be selected etc.            Pin   A? D?                      ET1010 / ET0884 – Microcontroller Applications   Page 61 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 4.5.3  ADCON2   The ADCON2 register configures the A/D clock source, programmed acquisition time and justification.       Figure 4.12 – ADCON2  You can also write ADCON2 = 0 b 0 0 0 1 0 1 1 0; to achieve the same results
When an A/D conversion is completed, the 10-bit result is stored in the registers ADRESH and ADRESL, either left-justified or right-justified, depending on the value of the ADFM bit, as shown below
Note that the other bits are filled with 0’s.  ET1010 / ET0884 – Microcontroller Applications   Page 62 of 140 ADFM = 1 10-bit result      7  6  5  4  3  2  1  0  7  6  5  4  3  2  1  0    7  6  5  4  3  2  1  0  7  6  5  4  3  2  1  0 0  0  0  0  0  0     0  0  0  0  0  0      ADFM = 0 ADRESH ADRESH ADRESL      ADRESL               10-bit, right-justified 10- bit, left-justified   Figure 4.13 – Right or left justification Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  A/D clock source   The A/D conversion time per bit is defined as TAD. (TAD is actually the period of the conversion clock.) The A/D conversion requires 11 TAD per 10-bit conversion.             The source of the A/D conversion clock is software selectable using ADCS2:ADCS0
For correct A/D conversions, the A/D conversion clock (TAD) must be as short as possible but greater than the minimum TAD i.e. ~0.7 us
Figure 4.14 – Minimum TAD The table below shows the resultant TAD times derived from the device operating frequencies and the A/D clock source selected.   Figure 4.15 – TAD vs device operating frequencies For instance, if Fosc = 48 MHz and ADCS2:ADCS0 = 110, TAD = 64 TOSC = 64 / 48 MHz = 1.33 us (> the 0.7 us minimum specified).   Acquisition time   For an accurate A/D conversion, the charge holding capacitor (refer to Figure 4.4) must be allowed to fully charge to the selected analogue input channel’s voltage level i.e
the input channel must be sampled for at least the “minimum acquisition time” before a conversion is started.  ET1010 / ET0884 – Microcontroller Applications   Page 63 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  You may refer to the PIC18F4550 datasheet for the calculation of the “minimum acquisition time”. (When it is difficult to do the calculation, large acquisition time is a safe choice.) ACQT2:ACQT0 selects the acquisition time
Setting ACQT2:ACQT0 = 010 cause acquisition time to be equal to 4 TAD
If TAD = 1.33 us, acquisition time = 4 x 1.33 us = 5.32 us.  Figure 4.16 – Acquisition & A/D conversion  As can be seen in the diagram above, after the GO bit is set, the holding capacitor continues to acquire the input for 4 TAD i.e. “automatic acquisition time”. [“Automatic acquisition time” does not happen when ACQT2:ACQT0 = 000
In this case, the user has to ensure enough acquisition time elapses before conversion is started with GO = 1 <– we will not use this.] After the acquisition time, conversion starts and it takes 11 TAD before conversion is completed.  Then the result loaded is loaded into ADRESH:ADRESL and the GO/ DONE  bit cleared to indicated end of conversion
The holding capacitor is connected to analogue input for the next cycle.                        ET1010 / ET0884 – Microcontroller Applications   Page 64 of 140  Note also that the port pins needed as analogue inputs must have their corresponding TRIS bits set (input)
The following steps should be followed to perform an A/D conversion: 1
turn on A/D module (ADCON0) Configure the A/D module -  configure voltage reference,  and analogue/digital I/O (ADCON1) -  select A/D input channel (ADCON0) -  select A/D acquisition time (ADCON2) -  select A/D conversion clock (ADCON2) -  Wait the required acquisition time (if required).  Start conversion -  Set GO/ DONE ) (ADCON0)  Wait for A/D conversion to complete, by polling for the GO/ DONE ) bit to be cleared.  After a minimum wait of 3 TAD, go to step 1 (or 2, if no changes to the configuration are required *,) for the next conversion. (*) If more than 1 analogue input channel is used, there is a need to go back to step 1 to “switch channel” i.e
the channels are sampled & converted one by one, in a predetermined order
Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 4.6  The complete A/D operation sequence   Note that it is possible for the completion of an A/D conversion to cause an interrupt
We will not use interrupt with A/D conversion in this chapter.                           ET1010 / ET0884 – Microcontroller Applications   Page 65 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 4.7   ADC Programming example   In the example below, a variable resistor is connected to AN0 and a program is written to configure the A/D converter and then to repeatedly sample the analogue input, convert to digital equivalent, and output the most significant 8-bits to the LED bar for display
Vdd A/D converter Analogue input AN0 Digital output at Port  8 5 V         “Trimmer”  or variable       resistor Figure 4.17 – Sampling the trimmer for display on the LED bar      main (void) {    TRISD = 0x00;    PORTD = 0x00;     // configure A/D converter module & switch it on    ADCON0 = 0 b 0 0 0 0 0 0 0 1;     ADCON1 = 0 b 0 0 0 0 1 1 1 0;       ADCON2 = 0 b 0 0 0 1 0 1 1 0;      while (1)       {       ADCON0bits.GO = 1;       while (ADCON0bits.GO == 1);       PORTD = ADRESH;       } }                  // configure Port D as output - for LED bar  // initialise Port D – all LED’s off // bits <5:2> = 0000, channel AN0 selected // bit <0> = 1, A/D activated (powered up) // bit <5> = 0, Vref- = Vss (0V) // bit <4> = 0, Vref+ = Vdd (5V) // bits <3:0> = 1110, pin AN0 as analogue input // bit <7> = 0, result left justified // bits <5:3> = 010, acquisition time = 4 TAD // bits <2:0> =  110, conversion clock = FOSC/64 // start A/D conversion // wait here for /DONE to becomes 0 // output upper 8-bit of result to LED bar  ET1010 / ET0884 – Microcontroller Applications   Page 66 of 140 references.  voltage references.  ADCON0bits.CHS3 = _____; ADCON0bits.CHS2 = _____; ADCON0bits.CHS1 = _____; ADCON0bits.CHS0 = _____;  4.  Determine the 10-bit result of an A/D conversion, given that ADFM = 0,  ADRESH = 0xA3 and ADRESL = 0x80
5.  If the above 10-bit result is to be displayed on 8 LED’s (of an LED bar) connected to PORT D, which of the following is a better choice? (a)  PORTD = ADRESH;  or  6.  Complete the C code below to select left justification, acquisition time of 4 TAD, (b)  PORTD = ADRESL; FOSC/64 as the clock source ADCON2bits.ADFM = _____; ADCON2bits.ACQT2 = _____; ADCON2bits.ACQT1 = _____; ADCON2bits.ACQT0 = _____; ADCON2bits.ADCS2 = _____; ADCON2bits.ADCS1 = _____; ADCON2bits.ADCS0 = _____;    Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 4.8  Review Questions  1.  Determine the digital result if Vin = 2.5V and 5V and ground are used as voltage  2.  Determine Vin if the digital result is 0111001110 and 5V and ground are used as 3.  Complete the C code below to select channel 3 for conversion                    ET1010 / ET0884 – Microcontroller Applications   Page 67 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 5  A brief revision on C programming language  5.1  C language fundamentals – #define & #include directives, comments, constants, variables, operators  This short chapter serves as a quick revision on the important    concepts in the C programming language previously covered in the “Structured Programming” module  5.2  Pre-Processor Directives 5.2.1  #define Directive    The #define pre-processor directive is used to define a constant  If you include the directive  #define switch_1  PORTBbits.RB5,  writing  if (switch_1 == 0)  is the same as writing if (PORTBbits.RB5 == 0) .     The usage of #define improves the portability of the code which means it would reduce the effort and complexity to migrate the C code to a different microprocessor       5.2.2  #include Directive    The #include directive includes  the code from another source file at the point where the #include appears in the source code.   The inserted file may contain any number of valid C statements.                 ET1010 / ET0884 – Microcontroller Applications   Page 68 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  5.3  Code Comments   Example:   Comments are used to describe and explain the source code.    The C pre-processor will parse the source code and remove any comments before actual compilation into assembler code   // This is a single line comment /* This is a multiple line comment
It is good to include lots of comments in your source code, so as to remind yourself why you write the code in a certain way
Others in the project team will also be able to follow the code
The comment can stretch over many lines and is terminated by a */    5.4  Constants  The value of a constant never changes
In C language, a constant can be a number, a single character or a character string.  Example:  12 0x0C 0b1100 “Hello World !” ‘y’ Decimal Hexadecimal for 12 Binary for 12 a string constant a char constant const float PI = 3.14; // this declares a floating point constant // it is a common practice to capitalize constants    Example:             ET1010 / ET0884 – Microcontroller Applications   Page 69 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  5.5  Variables  The value of a variable changes as the program executes
The variable can be of the following data types:  Data type  Number of Bits  Range Remarks no type not applicable not applicable void char single character unsigned char unsigned single character int integer unsigned int unsigned integer long long integer unsigned long unsigned long integer Float / double floating point 8 8 16 16 32 32 32 -128 to 127 0 to 255 -32768 to 32767 0 to 65535 -2,147,483,648 to 2,147,483,647 0 to 4,294,967,295 1.7549435 E-38 to 6.80564693 E+38 Figure 5.2 – Basic data types   Negative numbers are represented in the two’s complement format.   All variables must be declared before they are used
When you declare a variable, choose an appropriate data type.      Example:                char reply; // a char to store ‘y’ (yes) or ‘n’ (no) as reply unsigned char count; // this is a byte (or 8 bit) that stores // non-negative count value int num; // this is a 16-bit variable that stores both +ve & -ve // values, from -32768 to 32767  ET1010 / ET0884 – Microcontroller Applications   Page 70 of 140   Global variables are declared outside of functions   It can be accessed by any function with the same C source file  unsigned int ticks; // global variable can be used by any function that // appears after this unsigned char count; // local variable can be used by main only …
Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 5.5.1  Local variables    Local variables are declared inside a function can only be used by  statements within that function.     Functions where the local variables are not defined cannot read or write to the variables.   5.5.2  Global variables   Example: main (void) { }                       ET1010 / ET0884 – Microcontroller Applications   Page 71 of 140 addition subtraction + - *  multiplication / division  Example:  -b count – 163 negative b variable count minus 163 a multiplied by b c divided by b a * b c / b greater than > >=  greater than or equal to < <= ==  equal to !=  not equal to less than less than or equal to     Examples:          5.8  Relational operators  Compare two values and return 1 (for true) or 0 (for false) based on the comparison  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  5.6  Operators  5.7  Arithmetic operators Used for the calculation of the basic mathematical operations for below.     count > 0 value <= MAX input != BADVAL is count greater than 0 ? is value less than or equal to MAX ? is input not equal to BADVAL ? Flags & MASK Flags ^ 0x07 Val << 2 if MASK = 0b00000111, the upper 5 bits of Flags will be filtered or masked off, while the lower 3 bits will be unchanged
invert bits 0, 1 and 2 shift left by 2 bits i.e
multiply by 4        ET1010 / ET0884 – Microcontroller Applications   Page 72 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 5.9 Returns 1 is the result is evaluated as True and returns 0 if the result is False.  Logical operators   && || ! Logical AND Logical OR Logical NOT   Example:          & | ^ >> << Bitwise AND Bitwise OR Bitwise XOR Right shift Left shift Lecture_Open && (Students > MIN) - checking that the lecture theatre is open and there are enough students turning up 5.10 Bitwise operators  Bitwise operations are performed on bit level and allows the manipulation of specified individual bits.   Examples                 ET1010 / ET0884 – Microcontroller Applications   Page 73 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  5.11  C language fundamentals – functions & program control statements 5.11.1 Functions    Functions are the basic building blocks of a C program
All executable statements must reside within a function.   The main() is the entry point in every C program and must always be defined at least once as this is the function that will be first invoked when the microcontroller starts up after a reset.   A function prototype should be declared before the function is called.    A function prototype declares the return type, function name, and types of parameters for a function, but no other statements.   A function must be defined before it can be invoked else there the C code will not compile successfully.      Example:    } unsigned char AddOne (unsigned char x);  // prototype terminated by ; // actual function below unsigned char AddOne (unsigned char x) // x is a local variable { return (x + 1);                    ET1010 / ET0884 – Microcontroller Applications   Page 74 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  5.12  Program control statements    Program control statements control the flow of execution in a source code.    Relational and logical operators determine which execution path the code will branch to.     Loops    are also used to execute code iteratively
.1 Conditional “if-else”    “if-else” statements are called conditional statements.    The code encapsulated with an “if” block is only executed if the outcome of the evaluated condition is True.    Else the “else” code block is executed if the conditional statement result is    } evaluated False.  Example: if (second > 59) { second = 0; minute += 1;  if-else statement: The most general form of “if-else” is  if (expression) statement1 else statement2  Example #1: if (a < b) smaller = a;  // single statement smaller = b; else       ET1010 / ET0884 – Microcontroller Applications   Page 75 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________   Example #2: num = 0;  // multiple statement Valid = 0; if (num < 0) { } else Valid = 1;  5.12.2 Conditional “Switch Case”   Example:  In the scenario that there are several discrete “if-else if” conditions required, a cleaner implementation is to use the “switch case” conditional statements switch (expression) { case const1 : statement1(s) ; case const2 : statement2(s) ; break; break; statement3(s) ; break; : default : }   5.12.3 Iterative “for” Loops  iterations.      “for” loops are used to repeat a code execution for a predefined number of for (initialization; expression; increment) statement  ET1010 / ET0884 – Microcontroller Applications   Page 76 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Example:  unsigned char i; for (i = 0; i < 10; i++) do_something (); i = 0; i < 10 ? YES NO do_something (); i++;   Figure 5.3 – Flowchart for “for loop”                   ET1010 / ET0884 – Microcontroller Applications   Page 77 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 5.12.4 Conditional “while” Loops    “while” loops are used to repeat the execution of a block of code based on a    When the conditional statement is evaluated as True, the “while” loop code block defined condition  continues to the next iteration    However when the conditional statement is evaluated as False, the “while” loop code block is not executed and the “while” loops is stopped as code continues on the next executable line of code after the “while” loop code block.  The general form is while (expression) statement   Example #1:  The code below is alternative implementation to a “for” loop using the “while” loop instead and terminates after 10 iterations
i = 0;  while (i < 10) { do_something ();  i = i + 1; }    Example #2:  The code below runs an infinite “while” loop that will never terminate since the condition evaluated is always 1 or True.   while (1) {   } do_something_forever()     ET1010 / ET0884 – Microcontroller Applications   Page 78 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 5.13 Review Questions  1.  A C code variable “student_count” is defined to keep track of the number of  students in a lecture theatre
If the lecture theatre has a maximum seating capacity of 300 students, write 1 line C code to declare and initialize the variable “student_count with an initial value of 0.  2.  What is the resultant value of the variable “test_var_u8” after the C code below is executed?  unsigned char test_var_u8 = 0x01;  test_var_u8 = test_var_u8 << 4;           3.  Based on the PIC 18F4550, pins RA0 to RA7 are connected in active high configuration to LED0 to LED7 respectively.    unsigned char output_u8 = 0x80; /* Set all pins in PORTA as Digital Outputs */ TRISA = 0x00; Based on the following C code, which LED/s will be turned on after the code has finished execution?             /* Write output_u8 to PORTA to control LED0 to LED7*/ PORTA = output_u8; output_u8 = output_u8 | 0x02;     4.  Using the appropriate C pre-processor directives, rewrite the following code to improve the portability of the code to other microcontrollers in the future.  /* Configure Port B Pin 4 as Output */ TRISBbits.TRISB4 = 0;  /* Set Port B Pin 4 to logic high */ PORTBbits.RB4 = 1;    ET1010 / ET0884 – Microcontroller Applications   Page 79 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 6  PIC18F4550 Programmable Timers and Counters 6.1  Why are Timers and Counters needed in micro-controller applications?     For instance, you may want to switch off the light 30 seconds after the last person leaves a room: Many micro-controller applications have timing requirements
Sensor  Light On Sensor  Light Off after 30 s Figure 6.1 – Automatic room light Sometimes you may want to measure a time duration, for instance, how long has a signal been set to high
Signal  How long is the “high” pulse? Figure 6.2 – Measuring pulse width  You will learn how to schedule an event (e.g
light off 30 s after person leaves) and how to measure the elapsed time etc in the next section
Note that the two examples are “opposite”: In scheduling an event, you wait for certain duration to pass before you do something
In measuring the elapsed time, you wait for an event (pulse goes from high to low) before you stop the “stop watch” and see how long it has been.                                    ET1010 / ET0884 – Microcontroller Applications   Page 80 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  A counter counts up every time a clock pulse arrives: 16-bit  16 Count Clock Clock Count 0x0000  0x0001  0x0002  0x0003  0x0004 Figure 6.3 – 16-bit counting If the clock period is fixed and known, the counter becomes a “timer” i.e
a device that lets you know how much time has passed
For instance, clock period = 10 us, a count of 1,234 is equivalent to 12,340 us or 12.34 ms
The clock could be generated by events – for instance, boxes (on a conveyor belt) passing an infra-red sensor which produces pulses that can be used as a clock signal: IR detector  Clock signal from IR sensor                                         IR transmitter Box Counter How many boxes? Figure 6.4 – Box counting   In this case, the clock period is neither fixed nor known
So, the counter tells you how many boxes have moved pass the IR sensor but not how much time has passed
It is just a “counter”.  ET1010 / ET0884 – Microcontroller Applications   Page 81 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 6.2  Programmable timers / counters in PIC18F4550      The key features of each is highlighted in the table below: PIC18F4550 has 4 timers: Timer0 to Timer3
Feature\Timer Counting range Timer0 8-/16-bit timer or counter Timer1 16-bit timer or counter Pre-scaler 1, 2, 4…256 1, 2, 4, 8 Timer2 8-bit timer (TMR2) and period (PR2) registers 1, 4, 16 Also post-scaler 1, 2, 3,…6 internal on TMR2 & PR2 match can compare register value Timer3 16-bit timer or counter 1, 2, 4, 8 internal/ external on overflow can use TMR1 internal oscillator Clock source Interrupt internal/ external on overflow Other special features edge select for external clock internal/ external on overflow has its own internal oscillator Figure 6.5 – Key features of Timer0 to Timer3 As the timers are very similar, we will not study everything
We will learn how to use Timer0 well, and then learn the special feature of Timer2.                          ET1010 / ET0884 – Microcontroller Applications   Page 82 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 6.3  Using Timer0 to schedule an event   Before we go into the details of Timer0, let’s look at a simple scenario – you want an LED to be turned on, 0.1 second after a button is pressed
You can write a C program to achieve this: while (PORTBbits.RB0 == 1); // wait for “active low” button at RB0 to    Delay… PORTDbits.RD0 = 1;   //    be pressed                                  // 0.1 s delay // turn on “active high” LED at RD0 In the above example, the turning ON of the LED is scheduled to take place 0.1 second after the trigger i.e. “button pressed”
Let’s see how the 0.1 s delay can be achieved using Timer0
Registers associated with Timer0 operation   Timer0 operation uses the following registers: TMR0H, TMR0L, T0CON and the TMR0IF bit of the INTCON register
The key points are highlighted below
TMR0H and TMR0L (Timer0 High and Low Registers)                     TMR0H TMR0L D15  D14  D13  D12  D11  D10  D9  D8  D7  D6  D5  D4  D3  D2  D1  D0  These two 8-bit registers together form a 16-bit timer/counter.   INTCON (Interrupt Control Register) bit 2 –TMR0IF (Timer0 Interrupt “overflow” Flag)      TMR0IF    TMR0IF is set to 1 whenever the timer overflows i.e
count from FFFF to 0000 (in 16-bit mode) or from FF to 00 (in 8-bit mode).  Other bits are associated with the operations of other peripherals e.g
ADC etc.  Figure 6.6 – Timer0 registers TMR0H, TMR0L, INTCON  ET1010 / ET0884 – Microcontroller Applications   Page 83 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  T0CON (Timer0 Control Register) TMR0ON  T08BIT  T0CS  T0SE PSA  T0PS2  T0PS1  T0PS0   TMR0ON       T08BIT   D7    D6  Timer0 ON and OFF control bit 1 = Enable (start) Timer0 0 = Stop Timer0  Timer0 8-bit / 16-bit selector bit 1 = Timer0 is configured as an 8-bit timer/counter 0 = Timer0 is configured as a 16-bit timer/counter D5   D4   D3   Timer0 clock source select bit 1 = External clock from RA4/T0CK1 pin 0 = Internal clock (Fosc/4 from XTAL oscillator) Timer0 source edge select bit 1 = Increment on H-to-L transition on T0CK1 pin 0 = Increment on L-to-H transition on T0CK1 pin Timer0 pre-scaler assignment bit 1 = Timer0 clock input bypasses pre-scaler 0 = Timer0 clock input comes from pre-scaler output  T0CS        T0SE        PSA    T0PS2:T0PS0            Note that the use of the pre-scaler “steps down” the clock that reaches the timer/counter
For instance, an oscillator frequency of 48MHz used with a pre-scale value of 16 gives the timer/counter a clock with period = 1/(48MHz/4/16).   D2 D1 D0 0    0    0 = 1:2 Pre-scale value (Fosc/4/2) 0    0    1 = 1:4  0    1    0 = 1:8  0    1    1 = 1:16 1    0    0 = 1:32 1    0    1 = 1:64 1    1    0 = 1:128 1    1    1 = 1:256 Pre-scale value (Fosc/4/4) Pre-scale value (Fosc/4/8) Pre-scale value (Fosc/4/16) Pre-scale value (Fosc/4/32) Pre-scale value (Fosc/4/64) Pre-scale value (Fosc/4/128) Pre-scale value (Fosc/4/256)              Timer0 pre-scaler selector Figure 6.7 – Timer0 register T0CON  T0CON (Timer0 Control Register) TMR0ON  T08BIT  T0CS  T0SE PSA  T0PS2  T0PS1  T0PS0                 ET1010 / ET0884 – Microcontroller Applications   Page 84 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________   The following block diagram shows in a “schematic way”, how the various registers affect the Timer0 operations. (optional) T0CK1 pin Fosc/4 0 1 T0SE T0CS T0CON Programmable Pre-scaler 1:1 to 1:256 3 T0PS2:T0PS0 TMR0H:TMR0L 8/16-bit Timer/Counter registers 1 0 overflow turn  TMR0ON PSA 8/16- T08BIT Figure 6.8 – Timer0 block diagram TMR0IF [bit 2 of INTCON]                                               ET1010 / ET0884 – Microcontroller Applications   Page 85 of 140     1/12 us 0x0000 0x0001 0x0002 0xFFFE 0xFFFF 0x0000 5.4613 ms Rolling over causes TMR0IF = 1 Figure 6.9 – Timer0 calculation – example 1 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 6.3.2  Timer0 calculations  Example 1   Assuming the crystal oscillator (with Fosc = 48 MHz) is used as the clock source and the pre-scaler is not used, how long does it take for Timer0 (used as 16-bit timer) to count from 0x0000 to 0xFFFF and roll over? Answer:  Period = 1 / (Fosc/4) = 1 / (12MHz) = 1/12 us  Counting from 0x0000 to 0xFFFF and then rolling over is counting up 216 = 65536 times.  So, total time = 65536 x (1/12 us) = 5.4613 ms Fosc/4 = 48MHz/4 = 12MHz 16 bit timer                                  ET1010 / ET0884 – Microcontroller Applications   Page 86 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Example 2   Assuming the crystal oscillator (with Fosc = 48 MHz) is used as the clock source and the pre-scale value of 256 is used, how long does it take for Timer0 (used as 16-bit timer) to count from 0x0000 to 0xFFFF and roll over? Answer:  The pre-scaler “slows down” the clock (i.e
clock frequency is “stepped down” by 256 times
Delay will become 256 times as long, as shown below: Period = 1 / (Fosc/4/256) Total time = 65536 x (256 x 1/12 us) = 5.4613 ms x 256 = 1.3981 second [This is the longest delay using Fosc = 48 MHz.]                                      Fosc/4 = 48MHz/4 = 12MHz ÷256 16 bit timer 0x0000 0x0001 0x0002 0xFFFE 0xFFFF 0x0000 5.4613 ms x 256 = 1.3981 second Rolling over causes TMR0IF = 1    Figure 6.10 – Timer0 calculation – example 2  ET1010 / ET0884 – Microcontroller Applications   Page 87 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Example 3   Assuming the crystal oscillator (with Fosc = 48 MHz) is used as the clock source and the pre-scale value of 32 is used, what is the starting count value in order that when the timer overflows (i.e
counts from 0xFFFF to 0x0000), exactly 0.1 second has elapsed? Answer:  Step 1: Calculate the period of the clock signal that reaches the timer.  With pre-scale value of 32, Period = 1 / (Fosc/4/32) = 2.667 us Step 2: Calculate the number of counts equivalent to a given duration
A duration of 0.1 second is equivalent to counting up (0.1s / 2.667 us =) 37500 times
Step 3: Determine the count value to start from, by subtracting the answer from Step 2 from 65536.  Since the overflow occurs when 65535  0, we should start counting from (65536-37500 =) 28036 or 0x6D84  Fosc/4 = 48MHz/4 = 12MHz 32÷ 16 bit timer 0x???? Step 1: clock period = 2.667  Step 3: count up from 28036 or 0x6D84 Step 2: 0.1 second = count up 37500 times                       Rolling over causes TMR0IF = 1 0xFFFE 0xFFFF 0x0000 Figure 6.11 – Timer0 calculation – example 3           ET1010 / ET0884 – Microcontroller Applications   Page 88 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 6.3.3  Programming Timer0 to schedule an event   Let’s go back to the original problem: turning on an LED 0.1 second after a button is pressed
As computed in Example 3 in the previous section, a 0.1 second delay can be achieved using Fosc = 48 MHz, a pre-scale value of 32 and a starting count value of 0x6D84
The complete C program looks like this: T0CON = 0b10000100; // Timer on, 16-bit, Fosc/4, pre-scaler 32  while (PORTBbits.RB0 == 1); // wait for button to be pressed  INTCONbits.TMR0IF = 0; // clear the flag  TMR0H = 0x6D; // always write to TMR0H before TMR0L TMR0L = 0x84; while (INTCONbits.TMR0IF == 0); // wait here for Timer0 overflow // the previous 3 lines gives a delay of 0.1 second PORTDbits.RD0 = 1; // turn on LED  Figure 6.12 – Code to add a delay using Timer0                 2
3.              6.3.3.1 Steps to add a delay using Timer0  1
T0CON register is used to configure the timer (8 or 16 bit, clock source, clock edge if external clock is used, pre-scale value) and to turn on the timer
The timer will then start counting up, at the rate of the selected clock source.  An appropriate “starting count” value is written to the TMR0H:TMR0L registers
TMR0H should be written to first, before TMR0L.  Wait for the timer to “overflow”, by checking the TMR0IF bit of the INTCON register.  ET1010 / ET0884 – Microcontroller Applications   Page 89 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Lengthening the delay   There are several ways to lengthen the delay that Timer0 can produce,  1.  Use Timer0 as 16-bit, instead of 8-bit
2.  Use a lower frequency crystal (not easy for an assembled board)
3.  Use external clock and apply a slower clock at T0CK1
4.  Use a bigger pre-scale value
5.  Write a smaller number to TMR0H:TMR0L
Scheduling a periodic event using Timer0    How do you schedule a periodic event e.g
for the alarm to sound at 6 am every morning? Or for an LED to be toggled every 0.1 second? The complete C program to toggle an LED every 0.1 second follows:       T0CON = 0b10000100; // Timer on, 16-bit, Fosc/4, pre-scaler 32  while (1) // loop forever { INTCONbits.TMR0IF = 0; // clear the flag  TMR0H = 0x6D; // always write to TMR0H before TMR0L TMR0L = 0x84; while (INTCONbits.TMR0IF == 0); // wait here for Timer0 overflow // the previous 3 lines gives a delay of 0.1 second  PORTDbits.RD0 = ~ PORTDbits.RD0; // toggle RD0 } Figure 6.13 – Code to schedule a periodic event using Timer0                 Steps to schedule a periodic event using Timer0  1
Use T0CON to configure & turned on the timer, which will then start counting
Write a “starting count” to TMR0H:TMR0L
Check TMR0IF bit of INTCON register for timer overflow
Do “something” e.g
toggle LED, then go back to 1
to repeat.  2
4.      ET1010 / ET0884 – Microcontroller Applications   Page 90 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Delay using Timer   Since Delay can also be introduced easily with a loop that does nothing, why bother with Timer? Answer 1
Timer can be used with interrupt (which will be covered in the next chapter), so the PIC can do other things while waiting for the time to pass
Answer 2.Timer that uses external clock becomes an “event counter” (i.e
how many times an event happens, but we will not discuss this usage)
As mentioned, measuring elapsed time is “opposite” to scheduling an event
Let’s try a simple application, measuring the pulse width of a signal:   6.4  Using Timer0 to measure the elapsed time [Optional]             How long is the “high” pulse? Signal  Start timing   Stop timing Figure 6.14 – Measuring pulse width            Steps to measure a time duration using Timer0  The timer is configured & turned on
1.  2.  3.  4.   When the “low to high” transition occurs, the timer is “reset” to start counting from 0x0000 (this is similar to resetting the stop watch)
When the “high to low” transition occurs, the timer is stopped from counting further
The final count (multiplied by the clock period) gives the elapsed time i.e
the pulse width
We assume that the counter has not overflowed
You can modify the code below if the pulse width is long and overflow is likely.  ET1010 / ET0884 – Microcontroller Applications   Page 91 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________    T0CON = 0b10000100; // Timer on, 16-bit, Fosc/4, pre-scaler 32   while (PORTBbits.RB0 == 0); // wait for signal at RB0 to go high // other pre-scale value can be chosen           TMR0H = 0x00; // reset timer -- always write to TMR0H first TMR0L = 0x00; while (PORTBbits.RB0 == 1); // wait for signal at RB0 to go low T0CONbits.TMR0ON = 0; // stop timer // the time elapsed is now in TMR0H:TMR0L
To extract the 16-bit // value, use unsigned integer time_elapsed as follows: TempLow = TMR0L; // read TMR0L first TempHigh = TMR0H; Time_elapsed = TempHigh * 256 + TempLow; // Time_elapsed x 2.667 us then gives the “real time” elapsed  Figure 6.15 – Code to measure a time duration using Timer0                                             ET1010 / ET0884 – Microcontroller Applications   Page 92 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 6.5  Using Timer2 for PWM control of DC motor speed  6.5.1  Timer 2 – Introduction   As mentioned earlier, the four PIC18F4550 timers are very similar
We will not study everything – after learning Timer0 in details, we will now learn the special features of Timer2 (-- refer to Figure 6.5 to note the key differences between Timer2 and Timer0).                              The diagram below shows how Timer2 works
Fosc/4 Programmable Pre-scaler 1:1, 1:4, 1:16 2 TMR2 8-bit Timer register T2CKPS1:T2CKPS0 Comparator turn  TMR2ON 8-bit Period register reset EQ  Programmable Post-scaler 1:1 to 1:16 4 TOUTPS3:TOUTPS0 overflow T2CON PR2 Figure 6.16 – Timer2 block diagram    TMR2IF [bit 1 of PIR1] Timer2 is an 8-bit timer
The 8-bit register of Timer2 is called TMR2
Timer2 also has an 8-bit register called the period register (PR2)
We can set the PR2 register to a fixed value and Timer2 will increment from 00 until it matches the value in PR2
Then, the equal (EQ) signal will reset TMR2 to 00, and depending on the post-scaler, may raise the TMR2IF flag
The clock source for Timer2 is Fosc/4 with the options of both pre-scaler and post-scaler, as shown in the figure above
There is no external clock source for Timer2
In other words, it cannot be used as a counter.       ET1010 / ET0884 – Microcontroller Applications   Page 93 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________            D7 The registers associated with Timer2 operations are the following: TMR2 (Timer2 Register) D7  D6  D5  D4  D3  D2  D1  D0 PR2 (Period Register) D7  D6  D5  D4  D3  D2  D1  D0 PIR1 (Peripheral Interrupt Flag Register 1) bit 1 –TMR2IF (Timer2 Interrupt “overflow” Flag)     TMR2 is reset to 0 whenever TMR2 matches PR2
If no post scaler is used, TMR2IF is set to 1 whenever the match occurs
With post scaler, many matches have to occur before TMR2IF is set
TMR2IF    T2CON (Timer2 Control Register) 3 2 TOUTPSTOUTPS           D6 D5 D4 D3              D7 – not used  TOUTPS3:TOUTPS0         TMR2ON    T2CKPS1:T2CKPS0  D1 D0          D2                    TOUTPS1 TOUTPS0 TMR2ON T2CKPS1 T2CKPS0 Timer2 output post-scaler selector 0 0 0 0 = 1:1 Post-scale value 0 0 0 1 = 1:2 Post-scale value 0 0 1 0  = 1:3 Post-scale value … 1 1 1 1 = 1:16 Post-scale value Timer2 ON and OFF control bit 1 = Enable (start) Timer2 0 = Stop Timer2 Timer2 clock pre-scaler selector 0 0 = 1:1 Pre-scale value 0 1 = 1:4 Pre-scale value 1 X = 1:16 Pre-scale value Figure 6.17 – Timer2 registers TMR2, PR2, PIR1 and T2CON        ET1010 / ET0884 – Microcontroller Applications   Page 94 of 140      #include …  void main (void) {   TRISDbits.TRISD0 = 0;   PORTDbits.RD0 = 0;      T2CON = 0x00;   TMR2 = 0x00;    PR2 = 100;    T2CONbits.TMR2ON = 1;    while (PIR1bits.TMR2IF == 0);    PORTDbits.RD0 = 1;      T2CONbits.TMR2ON = 0;   PIR1bits.TMR2IF = 0;     while (1); }     // configure RD0 as output // turn OFF LED at RD0 // Timer2, no pre-/post- scaler  // TMR2 = 0   // load period register 2 // turn ON Timer2 // wait for TMR2IF to be raised // turn ON LED at RD0 // turn OFF Timer2  // clear flag // stay here Figure 6.18 – Code to add a delay using Timer2  To introduce the longest delay, use the maximum pre-scale value (16) and the maximum post-scale value (16), and load the period register with the biggest 8-bit number (255)
Effective, Timer2 is clocked by Fosc / 4 / 16 / 16 (= 46875 Hz)
This gives a clock period of 1/46875 s
TMR2 counting from 0 to 255 and back to 0 takes 256/46875 s = 0.00546 s or 5.46 ms (max delay)
Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Let’s see how we can write a C-program to turn on the LED at pin RD0 of PORTD when TMR2 reaches value 100:                         ET1010 / ET0884 – Microcontroller Applications   Page 95 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 6.5.2  PWM (Pulse Width Modulation)   PWM (Pulse Width Modulation) is frequently used to control the speed of a DC motor
For instance, a small DC motor can be made to turn by applying a d.c
voltage (e.g
5V) to it
When 5V is applied, it turns at a certain speed
When the 75% duty cycle wave is applied, the motor slows down – this is because effectively, it is getting 5V x 75% or 3.75V d.c
When the 50% duty cycle wave is applied, the motor slows down further, as it is effectively getting 2.5V d.c.   100 % duty cycle 75 % duty cycle 75 % of period is HIGH Period 50 % of period is HIGH                                           50 % duty cycle Period Figure 6.19 – 100%, 75% and 50% duty cycle waves  ET1010 / ET0884 – Microcontroller Applications   Page 96 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 6.5.3  PIC18F4550’s PWM capability     Compare means this: when a timer counts up to a certain value, an event is triggered (e.g
a certain pin set to high or toggled or…) i.e
we can program an event to occur at a certain time
PIC18F4550 has a CCP (Capture Compare) module
Capture means the opposite: when an event (e.g
low to high transition) occurs at a certain pin, the content of a timer is copied i.e
we know when the event occurs
We will not study Capture-Compare in this module
However, the CCP module comes with PWM capability and we will focus on just this
The PWM output will appear at RC2 i.e
Port C, Pin 2
So RC2 must be made an output pin
TRISCbits.TRISC2 = 0; [This pin is also called CCP1.] The bottom 4 bits of the CCP1 Control Register (CCP1CON) must be set to 1100 for PWM operation:   CCP1CON = 0b00001100; CCP1CON (CCP1 Control Register) D7 D6 DC1B1  DC1B0  CCP1M3  CCP1M2  CCP1M1  CCP1M0          Point  1      Point  2                      1 1 0 0 for PWM mode  Other combinations for Capture / Compare modes not studied in this module Figure 6.20 – CCP register CCP1CON  ET1010 / ET0884 – Microcontroller Applications   Page 97 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Sample calculations   Assuming a 5 kHz, 25% duty cycle wave is required:  Period = 1 / 5k = 0.2 ms
High Time = Period x 25% = 0.2 ms x 25% = 0.05 ms.                              High Time = 0.05 ms Period = 0.2 ms The “Period” is specified using PR2 register using the formula below: PWM period = ( PR2 + 1 ) x 4 x N x Tosc where     PR2 is the 8-bit Period register N = Timer2 prescaler value of 1, 4 or 16, as set in T2CON register Tosc = 1 / Fosc, where Fosc = 48 MHz in our case    Assuming pre-scaler N = 16, and Tosc = 1 / 48M.  Substitute into formula: PWM period = ( PR2 + 1 ) x 4 x N x Tosc 0.2m = ( PR2 + 1 ) x 4 x 16 x (1 / 48M)  => PR2 = 149      Point  3 The “High Time” is specified using another register called CCPR1L, as follows:  High Time = 25% of Period  25% x 149 = 37.25 = 37 (truncate the decimal portion)  => CCPR1L = 37        Point  4  ET1010 / ET0884 – Microcontroller Applications   Page 98 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________   Here, the “High Time” is specified using the 8-bit CCPR1L register
The accuracy can be extended to 10 bits (i.e
2 decimal places) if necessary
The details can be found in PIC18F4550 datasheet.     PWM programming        We will now put everything together to program the PIC18F4550 to produce a 5 kHz, 25% duty cycle PWM wave: TRISCbits.TRISC2 = 0; // RC2 as output  CCP1CON = 0b00 00 1100; // PWM mode   Point  1 Point  2     PR2 = 149;  // Period   CCPR1L = 37; // High Time  TMR2 = 0; // start from 0  T2CON = 0b0 0000 1 10; // no post-scale, Timer2 on, pre-scale 16 Point  3  Point  4   while (1) { // PWM wave generated continuously at RC2, without further code // PIC free to do other things…… } TMR2 First CCPR1L, then PR2 Comparator CCP1 (RC2) Period (PR2) High Time (CCPR1L)       Output waveforms (optional)                  2
TMR2 matches CCPR1L, RC2 goes low, TMR2 continues counting up… 1.  RC2 goes high, TMR2 starts counting up from 0… 3
TMR2 matches PR2, RC2 goes high, TMR2 reset to 0 and the cycle is repeated…    Figure 6.21 – Sequence of events to produce PWM output  ET1010 / ET0884 – Microcontroller Applications   Page 99 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 6.6  Review Questions   1.  Describe what is the difference between a timer and a counter? 2.  Sketch a 5 kHz, 25% duty cycle wave with maximum amplitude of 5volts
3.  Using a pre-scale value of 16, determine the starting count value so that when the timer overflows, exactly 0.025 second has elapsed
a.  Calculate the period of the clock signal that reaches the timer
b.  Calculate the number of counts equivalent to a given duration
c.  Determine the count value to start from, by subtracting the answer from Step 2 from 65536
4.  What is the longest delay that can be introduced using Timer2? 5.  Give the binary pattern to be written to the T0CON register to turn on Timer0 as a 16-bit timer using internal clock (Fosc/4) and a pre-scale value of 32.                    ET1010 / ET0884 – Microcontroller Applications   Page 100 of 140  Interrupts Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 7 7.1  Introduction to interrupts   An interrupt is a hardware signal indicating that an event has occurred due to external or internal actions
This signal causes the microcontroller to halt the execution of the current instruction and jump to an Interrupt Service Routine (ISR) to execute code handling the triggered interrupt
Many peripherals e.g
I/O port, ADC, timer, serial port can be active simultaneously in a micro-controller application
The micro-controller needs to check for various events (e.g
a change in the voltage at an input pin, the completion of an A to D conversion, timer overflow, serial byte received) and responds appropriately
For instance, if a user presses a button (causing a change in the voltage at an input pin), the micro-controller may need to turn on a light
Or, when the A to D conversion (of a temperature input, say) is completed, the micro-controller may need to display the result on an LCD display
Or, when the timer overflows, it is time to switch off the heater.                                User button at Input pin Light Temperature sensor and ADC Time = 12:34 Timer Heater LCD display Temp. = 32 deg
Figure 7.1 – Many active peripherals, a busy “automation” micro-controller    The micro-controller can respond to “events” by 2 methods: polling or interrupt.  ET1010 / ET0884 – Microcontroller Applications   Page 101 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  while (1) {  } if (PORTBbits.RB0 == 1) …. // do something if (INTCONbits.TMR0IF == 1) … // do something else … // do other stuff, as micro-controller usually have a handful… Micro-controller main prog 1
Any change in voltage? If so, do something
Input pin 2
Timer overflow? If so, do something
Timer 3
Other tasks to perform     Figure 7.2 – Polling method to respond to event   As you can see, polling means “checking” in a round robin fashion and no priority can be assigned to the more important event i.e
if the micro-controller is busy responding to a change in voltage at a port pin, it cannot do anything else even if the “more urgent” Timer0 overflow occurs during this time
Sometimes, an event hardly occurs and the micro-controller wastes time polling for the event
Polling   The code below shows how polling is done, for 2 events: 1.) RB0 changes from 0 (low) to 1 (high) and 2.) Timer0 overflows:                                  ET1010 / ET0884 – Microcontroller Applications   Page 102 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Interrupt   In the interrupt method, whenever a peripheral needs something to be done, it notifies the micro-controller, which stops whatever it is doing and “serves” the peripheral. (The program associated with the interrupt is called the interrupt service routine or ISR).  After that, the micro-controller goes back to continue what it was doing
The interrupt method does not tie down the micro-controller (as you will see later) and allows priority to be assigned to the various events
Micro-controller main prog 3
Other tasks to perform Interrupt 1
Any change in voltage? If so, interrupt main prog
Input pin Interrupt 2
Timer overflow? If so, interrupt main prog
Timer   Figure 7.3 – Interrupt method to respond to event As an analogy, you could be reading newspaper the whole day (3 in above figure)
But when the door bell rings (1) or there is a buzz tone on your hand phone (2), you are interrupted – you stop reading your newspaper and go to open the door or reply to an SMS
After that, you continue reading your newspaper where you left off
We will learn only the basics of interrupt in this chapter, focusing on Timer0 interrupt and INT0 external hardware interrupt
We will also learn how an ISR (interrupt service routine) can be written.   An “interrupt service routine” is a program / function used by a micro-controller to “serve” a peripheral or an event that needs attention.                                   ET1010 / ET0884 – Microcontroller Applications   Page 103 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 7.2  PIC18F4550’s Timer0 interrupt   In Chapter 6, we learn how to use Timer0 and Timer2 (briefly)
Let’s see how we can use Timer0 with Interrupt in this section.                         The complete C program to toggle an LED every 0.1 second follows
Take a few minutes to understand this (again).   T0CON (Timer0 Control Register) TMR0ON  T08BIT  T0CS  T0SE PSA  T0PS2  T0PS1  T0PS0  TRISDbits.TRISD0 = 0; // RD0 as output T0CON = 0b10000100; // Timer0 on, 16-bit, Fosc/4, pre-scaler 32 while (1) // loop forever {    TMR0H = 0x6D; // load Timer0 for a 0.1 second delay    TMR0L = 0x84;    while (INTCONbits.TMR0IF == 0); // wait for Timer0 overflow    // the previous 3 lines gives a 0.1 second delay    INTCONbits.TMR0IF = 0; // clear the flag    PORTDbits.RD0 = ~ PORTDbits.RD0; // toggle RD0 } Figure 7.4 – C code to toggle LED every 0.1 second       The line highlighted in bold is checking for “Timer0 overflow” i.e
polling
Let’s see what changes we need to make, if we decide to use interrupt instead of polling
To enable the Timer0 interrupt, we must first set both the GIE (Global Interrupt Enable) and the TMR0IE (Timer0 Interrupt Enable) bits in the INTCON register
INTCON (Interrupt Control Register) GIE 1   TMR0IE 1     TMR0IF      You can consider GIE as the “main switch”, and TMR0IE as the “switch for a particular light”
Both must be switched on, before the light is turned on
The C-code to do this follows: INTCONbits.GIE = 1; // Global Interrupt Enable INTCONbits.TMR0IE = 1; // Timer0 Interrupt Enable   ET1010 / ET0884 – Microcontroller Applications   Page 104 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________   That is the easy part
The difficult part is, we must re-organise the C-code for polling (on the previous page) to change it into the C-code for interrupt (on the next page)
The explanation follows:   Explanatory Notes  1
The lines that need to be executed once before the while (1) loop still remain before the while (1) loop:  set RD0 as output, turn on Timer0: 16 bits, Fosc/4, pre-scaler 32
Timer0 interrupt is enabled by setting both GIE (Global Interrupt Enable) and TMR0IE (Timer0 Interrupt Enable)
The lines that need to be executed when Timer0 overflows have been moved from the while (1) loop to the “interrupt service routine” (called my_Timer0_isr or any other suitable name)
Note however that the line that polls for “Timer0 overflow” i.e
while (INTCONbits.TMR0IF == 0); is NO LONGER required, as interrupt is used, instead of polling
When TMR0IF becomes 1, the micro-controller will be “notified”.  2.  3.                   NEW “interrupt” code for Timer0             // The compiler will place this at a predefined location: 0x0008 for “high  // priority interrupt” service routine. (Similarly, 0x0018 for “low priority  // interrupt” service routine and 0x0000 for “reset” service routine.) void interrupt my_Timer0_isr (void) {    TMR0H = 0x6D;    TMR0L = 0x84;    INTCONbits.TMR0IF = 0;    PORTDbits.RD0 = ~PORTDbits.RD0; } void main (void) {    TRISDbits.TRISD0 = 0;    T0CON = 0b10000100;    INTCONbits.GIE = 1;   INTCONbits.TMR0IE = 1;    while (1)    {       // micro-controller freed to do other things here    } } ORIGINAL “polling” code for Timer0 ..main… TRISDbits.bTRISD0 = 0; T0CON = 0b10000100;  while (1) {    TMR0H = 0x6D;    TMR0L = 0x84;    while (INTCONbits.TMR0IF == 0);        INTCONbits.TMR0IF = 0;    PORTDbits.RD0 = ~PORTDbits.RD0; }  Figure 7.5 – Changing code from “polling” to “interrupt”  ET1010 / ET0884 – Microcontroller Applications   Page 105 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________    As a result of 3 above, the micro-controller is not kept busy (checking for TMR0IF to become 1 *)
It is now free to do other things
Of course, what it does with the “free time” depends on the application. (*) Checking “Timer0 overflow” all the time is like checking if there is a visitor at the door constantly – you might as well just read your newspaper! Note that when Timer0 overflows, whatever need to be done will still be done – the micro-controller will not be spared this effort!   The codes that handle Reset, High Priority Interrupt, Low Priority Interrupt must start at specific memory locations (called “interrupt vectors”), as follows: Interrupt Power-on Reset High Priority Interrupt Low Priority Interrupt Location (hex) 0000 0008  0018  If priority feature is not used, all interrupts are treated as high priority interrupts
This is what is happening here i.e
our Timer0 interrupt is “high priority”, to be “served” at location 0x0008
A low priority interrupt service routine will appear like this: void interrupt low_priority name_of_ISR (void) {  // …  }  Note that from 0x0008 to 0x0018, there are only a few bytes (16 bytes to be exact)
If the code to service the high priority interrupt is longer than 16 bytes, it may be necessary to write the code elsewhere and a “GOTO” is placed at 0x0008 to “branch” there
We will not discuss this further
In the lab, a “boot-loader” is used in the PIC18F4550
This program downloads a user program from a PC via the USB port
The use of the boot-loader program affects the placement of the ISR
Again, we will not discuss this further.  To recap, so far we have re-examined the C-code that toggles an LED every 0.1 second and re-organised the code so that we don’t have to poll for “Timer0 overflow”
Instead interrupt is used and when Timer0 overflows, interrupt occurs and whatever needs to be done will be carried out by the interrupt service routine
Changing from polling to interrupt in effect, pass the role of event checking from the C-code to the hardware
If you wish to know which lines of the C-code the micro-controller will execute, before and after Timer0 overflows, read the optional material below: 4
5.      (#)  ()           ET1010 / ET0884 – Microcontroller Applications   Page 106 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  A void main (void) {    ……  // set up, including interrupt    while (1)    {       // assume the micro-controller does these lines all the time,       //     when not interrupted by Timer0 overflow:        // statement_1;        // statement_2;        // statement_3;        // statement_4;    } } D G B C F Figure 7.6 – Which lines get executed, before and after an interrupt?   After setting up (A), including interrupt, the statements 1-4 get executed, over  and over again (B, C…).  If Timer0 overflows (i.e
TMR0IF=1 and interrupt occurs) when the micro-controller is executing statement_2 (D), it will finish the line of code before serving the Timer0 interrupt.   To handle the interrupt, it will go to the interrupt service routine (my_Timer0_isr) at location 0x0008 and execute the code there (E).   After executing the routine, the micro-controller will return to where it was i.e
to continue running from statement_3 (F, G…), until another interrupt
Timer0 interrupt – execution sequence (Optional)   // At location 0x0008 void interrupt my_Timer0_isr (void) {    …… } E                                     ET1010 / ET0884 – Microcontroller Applications   Page 107 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 7.3  PIC18F4550’s INT0 external hardware interrupt   The PIC18F4550 has 3 external hardware interrupts: INT0, INT1 and INT2 which use pins RB0, RB1 and RB2 respectively
We will discuss INT0 (and INT1 and INT2 are similar in terms of operation).                                The INT0 interrupt responds to a change of voltage (from low to high – default) i.e
a transition at RB0
To enable the INT0 interrupt, we must first set both the GIE (Global Interrupt Enable) and the INT0IE (INT0 Interrupt Enable) bits in the INTCON register
GIE 1   INTCON (Interrupt Control Register)   INT0IF      INT0IE 1   When there is a rising edge at RB0, the INT0IF bit of the INTCON register will be set
The follow C-code has been written to toggle the LED at RD0 whenever there is a rising edge (i.e
a low to high transition) at RB0: TRISBbits.TRISB0 = 1; // RB0 as input TRISDbits.TRISD0 = 0; // RD0 as output  while (1) // loop forever {    while (PORTBbits.RB0 == 0); // wait for RB0 to become 1    PORTDbits.RD0 = ~ PORTDbits.RD0; // toggle RD0    while (PORTBbits.RB0 == 1); // wait for RB0 to become 0 }     Figure 7.7 – C code to toggle LED every time there is a rising edge at RB0 As before, we will re-organise the C-code for polling (on the previous page) to change it into the C-code for interrupt (on the next page).  ET1010 / ET0884 – Microcontroller Applications   Page 108 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  INT0 (external hardware) interrupt code    // The compiler will place this “high priority interrupt” service routine // at the predefined location 0x0008.                                void interrupt my_INT0_isr (void) {    INTCONbits.INT0IF = 0; // clear flag    PORTDbits.RD0 = ~PORTDbits.RD0; } void main (void)` {    TRISBbits.TRISB0 = 1;    TRISDbits.TRISD0 = 0;    INTCONbits.GIE = 1;   INTCONbits.INT0IE = 1;    while (1)    {       // micro-controller freed to do other things here       Statement_1;       Statement_2;       Statement_3;    } } Figure 7.9 – INT0 interrupt code Note that the INT0IF flag must be cleared in the interrupt service routine
Figure 7.10 – INT0 interrupt code execution sequence For INT0 (and also INT1 and INT2), it is also possible for interrupt to occur when there is a falling edge (i.e
a high to low transition) at RB0.   This is done by clearing the INTEDG0 bit of the INTCON2 register
INTCON2 (Interrupt Control Register 2)   INTEDG0 0             INTEDG0 = 0: INT0 interrupt on falling edge at RB0 INTEDGO = 1: INT0 interrupt on rising edge at RB0 (power-on reset default)  ET1010 / ET0884 – Microcontroller Applications   Page 109 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 7.4  PIC18F4550’s other interrupt features  How do you use both Timer0 and INT0 (external hardware) interrupts together in a program? The program outline below shows how: 7.4.1  Multiple interrupt sources    // function prototypes void my_Timer0_isr (void); void my_INT0_isr (void);  // code at location 0x0008  void interrupt my_isr (void) {    if (TMR0IF == 1)       my_Timer0_isr;    if (INT0IF == 1)       my_INT0_isr; }  void my_Timer0_isr (void) {    // service Timer0 overflows    INTCONbits.TMR0IF = 0; // clear flag }  void my_INT0_isr (void) {    // service rising edge at RB0    INTCONbits.INT0IF = 0; // clear flag }  void main (void)` {    // set up    // enable interrupts    while (1)    {      // do other things here    } } Figure 7.11 – Program (outline) to service multiple interrupt sources   7.4.2  Other interrupt sources    PIC18F4550 have many interrupt sources 1.  Timer1/2/3 interrupts (beside Timer0) 2.  External hardware interrupts INT1/2 (beside INT0) 3.  Serial comm
receive/transmit interrupts 4.  PORTB change interrupt (any pin of PORTB changed, interrupt occurs) 5.  ADC interrupt 6.  CCP (compare/capture/PWM) interrupts          ET1010 / ET0884 – Microcontroller Applications   Page 110 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 7.4.3  Interrupt priority     By default, all interrupts are “high priority”, to be served from 0x0008
It is also possible to make some interrupts “high priority” (to be served from 0x0008) and others “low priority” (to be served from 0x0018).   This is done by setting the IPEN (Interrupt Priority ENable) bit in the RCON register
When interrupt priority is enabled, we must classify each interrupt source as high priority or low priority
This is done by putting 0 (for low priority) or 1 (for high priority) in the IP (interrupt priority) bit of each interrupt source
The IP bits for the different interrupt sources are spread across several registers – INTCON, INTCON2, INTCON3, IPR1 and IPR2
We will not go into the details of all these
A higher priority interrupt can interrupt a low priority interrupt but NOT vice-versa
So, if you are reading the newspaper (your while(1) loop…) and your hand phone buzzes (low priority interrupt), you stop reading the newspaper to reply an SMS (low priority interrupt service routine)
While doing that, the door bell rings (high priority interrupt), you stop messaging to open the door for your mom (high priority interrupt service routine)
After that, you can return to your message, followed by the newspaper.                              Summary   In the interest of time, this chapter only focuses on Timer0 interrupt and INT0 external hardware interrupt
We discuss the differences between polling and interrupt, how to enable interrupt, how to write interrupt code and the sequence of code execution when interrupt occurs.  ET1010 / ET0884 – Microcontroller Applications   Page 111 of 140  Can priority be assigned to events? Does micro-controller have to monitor continuously? Polling   Interrupt   2.  Which of the following conditions is/are necessary in order for Timer0 overflow to be serviced by an interrupt service routine?  A.  Global Interrupt Enable bit (in the INTCON register) must be set
B.  Timer0 (Overflow) Interrupt Enable bit (in the INTCON register) must be set
C.  Timer0 overflow has occurred i.e
Timer0 Overflow (Interrupt) Flag bit (in the INTCON register) is set
3.  Write the C-code to enable the interrupt INT0
Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 7.5  Review Questions  1.  Fill in the table below to show the differences between the 2 methods by which a  micro-controller can respond to events.                                   ET1010 / ET0884 – Microcontroller Applications   Page 112 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  4.  Show the sequence of execution i.e
which C statement is executed first, which second etc, for the case where the first rising edge at RB0 occurs when the PIC is executing Statement_2 for the first time.  Sequence Number  1 C Code   INTCONbits.INT0IF = 0;  PORTDbits.RD0 = ~PORTDbits.RD0;  TRISBbits.TRISB0 = 1;  TRISDbits.TRISD0 = 0;  INTCONbits.GIE = 1;  INTCONbits.INT0IE = 1;  Statement_1;  Statement_2;  Statement_3;          Code Location    my_INT0_isr   my_INT0_isr   main   main   main   main   main   main   main                 ET1010 / ET0884 – Microcontroller Applications   Page 113 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 8  Serial Communications 8.1  Basics of serial communication  Sender 8.1.1  Serial vs
parallel                 Serial Transfer 0      1  Sender Receiver Parallel Transfer D7 D6 D0 1 0 1 Receiver    Figure 8.1 – Serial vs
parallel data transfer Serial data transfer is slower, but costs less as less wire is required
PIC18F4550 is an 8-bit micro-controller
The 8-bit data that it usually handles must be converted using a parallel-in-serial-out shift register, before serial transmission
Modulation / demodulation     If the serial data is to be transferred over the telephone line, a modem is required
Modulation means converting the binary data (0’s and 1’s) into “audio tones” while demodulation means the reverse.              ET1010 / ET0884 – Microcontroller Applications   Page 114 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 8.1.3  Synchronous vs
asynch 8.1.4  ronous   The synchronous method transfers a block of data (multiple bytes) at a time whereas the asynchronous method transfers a single byte at a time
Special IC chips are made to make it easier to do serial data communication
They are called UART (universal asynchronous receiver-transmitter) and USART (universal synchronous-asynchronous receiver-transmitter)
PIC18F4550 has a built-in USART, to be described in a later section.  A Byte 4 Byte 3 Byte 2 Byte 1  B Synchronous transfer ..idle Byte 2 ..idle Byte 1  A  B Asynchronous transfer                                           Figure 8.2 – Synchronous vs
asynchronous data transfer  ET1010 / ET0884 – Microcontroller Applications   Page 115 of 140  Device A Device A Transmitter Device B Receiver Simplex Transmitter Half Duplex Data can only flow   Data can only flow in one direction at any one The following shows how two devices can communicate with each other
Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 8.1.5  Simplex, half-duplex and full-duplex                                       directions at the same Data can flow in both Full Duplex 1 2 Device B Receiver Receiver Transmitter Device B Transmitter Device A Transmitter time 1 2  Receiver Receiver 2 1 Figure 8.3 – Simplex, half- and full-duplex transfers          ET1010 / ET0884 – Microcontroller Applications   Page 116 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 8.1.6  Serial communication protocol   Two parties that communicate with one another must agree on a protocol i.e
a set of rules to make sense of the serial data – how the data is packed, how many bits constitute a character, and when the data begins and ends
For instance, the ASCII ‘A’ or 0x41 or 0b01000001 can be framed in the following way: “One character” D7 D0 Space Stop bit 0 1 0 0 0 0 0 1 Mark Start bit                                   Goes out last Goes out first Figure 8.4 – Framing ASCII ‘A’ with one start bit and one stop bit  The start bit is always one bit but the stop bit can be one or two bits
The start bit is always a ‘0’ (low) and the stop bit(s) is ‘1’ (high)
Note that LSB (D0) is sent out first
When there is no transfer, the signal is ‘1’ (high) which is referred to as mark
The data can be 7 bits wide or 8 bits wide (as in the above example)
In some system, the parity bit of the character byte is included in the data frame (before the stop bit) to maintain data integrity
The parity bit is odd or even
In the case of odd parity bit, the number of 1’s in the data bit, including the parity bit, is odd
The rate of data transfer in serial data communication is stated in bps (bits per second)
Sometimes, this is referred to as the baud rate
We will later learn how to specify the data transfer rate, how many data bit, whether to use odd/even/no parity and how many stop bit when serial communication is used in PIC18F4550.  ET1010 / ET0884 – Microcontroller Applications   Page 117 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 8.1.7  RS232 interfacing standards   RS232 is the most widely used serial I/O interfacing standard, which allows PCs and numerous types of equipment made by different manufacturers to be connected to one another.                        In RS232, a ‘1’ is represented by -3 to -25 V while a ‘0’ is represented by +3 to +25 V
To connect any RS232 equipment to a micro-controller that produces TTL voltages (0 V for ‘0’ and 5 V for ‘1’), a voltage converters such as MAX232 or MAX233 (a kind of line driver) can be used
The connector used for the serial data cable can be male / female, 9-pin (so called DB9) or 25 pins (DB25)
Figure 8.5 – DB9 connector  The simplest connection between a PC and a micro-controller requires a minimum of 3 pins: Tx (Transmit), Rx (Receive) and ground, as shown below
Ensure that the Tx of one equipment goes to the Rx of the other equipment
Sometimes, other pins e.g
CTS (Clear To Send) are also used for “hand-shaking”. ‘0’ = 0 V ‘1’ = 5 V PIC MAX232 Tx Rx Gnd ‘0’ = +15V ‘1’ =  Tx Rx Gnd PC (with MAX232) Rx Tx Figure 8.6 – Micro-controller serial port to PC COM port A PIC communicating with another PIC may do away with the MAX232, so that they communicate using TTL voltages
Still, Tx and Rx must be interchanged.     ET1010 / ET0884 – Microcontroller Applications   Page 118 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________   Nowadays, COM ports (RS232 ports on a PC) are disappearing and replaced by USB ports
A “COM-to-USB converter” allows PC with only USB port to control devices with only RS232 interface e.g
a thermal label printer.      8.2  PIC18F4550 connection to RS232    As can be seen below, Tx (transmit) shares pin 25 with RC6 etc while Rx (receive) shares pin 26 with RC7 etc.          Figure 8.7 – Tx and Rx pins on PIC18F4550 The following diagram shows how a PIC18F4550 can be connected to a MAX 233 (voltage converter) and then to a DB9 connector
One advantage of using MAX 233 (or MAX 232) is that only a 5 V supply is needed although it converts TTL voltages to higher RS232 voltages
The voltage converter has 2 sets of line drivers, but only one set is used below.         ET1010 / ET0884 – Microcontroller Applications   Page 119 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  MAX232 requires 4 capacitors while the more expensive MAX233 does not require any capacitor (so save PCB space!)
However, the two are not pin-to-pin compatible
Vcc PIC18F4550 Tx Rx 25 26 Vcc 7 MAX233 13 14 12 17 11 15 16 10 2 T1_in 3 R1_out 1 T2_in T1_ou 5 R1_in 4 T2_ou 18 20 R2_out R2_in 19 DB9 2 3 5 TTL side 6 9 RS232 side       Figure 8.8 – Connecting PIC18F4550 to MAX233 and then to DB9                                             ET1010 / ET0884 – Microcontroller Applications   Page 120 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 8.3  The registers associated with serial port operations   PIC18F4550 serial port operations require setting up (or writing to) / checking (or reading from) a number of registers
Let’s start with “SPBRG”
Below, the registers will be described in just enough details to get things going
You can always read up the PIC18F4550 data-sheet or a good book, or do a Google-search, if you are working on a PIC18 serial comm
project and get stuck
SPBRG – setting up the baud rate   You can check whether your PIC-based system can send or receive data through its serial port by connecting it (see Figure 8.8 / 8.6) to the COM port of an IBM PC/compatible and running the Hyper-Terminal software on the PC.                           Some of the common baud rates supported by PC Hyper-Terminal are: 1,200 2,400 4,800 9,600 19,200 38,400 57,600 115,200 The PIC18 transfers and receives data serially at many different baud rates
The baud rate in the PIC18 is programmable with the help of the 8-bit register called SPBRG
For a given crystal frequency, the value loaded into the SPBRG decides the baud rate
The relation is given by the formula: Desired Baud Rate = Fosc / [ 64 ( X + 1 ) ] Where X is the value loaded into the SPBRG register
Assuming Fosc = 48 MHz and desired baud rate = 9,600 9,600 = 48 x 106 / [ 64 ( X + 1 ) ] So, X = 77.125 = 77 (nearest integer) The C-code is simply   SPBRG = 77; The error introduced by the rounding can be determined as follows
With X = 77 (instead of 77.125), baud rate    = 48 x 106 / [ 64 ( 77 + 1 ) ] = 9615.385 ( = 0.16% error - insignificant)   ET1010 / ET0884 – Microcontroller Applications   Page 121 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 8.3.2  TXREG – Writing data to be transmitted   For a byte of data to be transmitted via the TX pin, it must be written to the TXREG register – an 8-bit register
The C-code is simply   TXREG = byte_out; When this happens, the byte is fetched into the Transmit Shift Register (TSR - not accessible by the programmer) which frames it with the start and stop bits and then transfers the 10-bit data serially out via the TX pin
TXSTA – transmit status and control   This is an 8-bit register used to select the synchronous/asynchronous mode, 8-bit/9-bit data transmission, high/low baud rate, enable/disable transmit, among other things
RCREG – retrieving data received   When the data bits are received serially via the RX pin, the PIC “de-frames” them by eliminating the stop and start bits, making a byte out of the data received, and then placing it in the RCREG register
The C-code to read the data received is  byte_in = RCREG;              ET1010 / ET0884 – Microcontroller Applications   Page 122 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Figure 8.9 – TXSTA register  To select the asynchronous mode, 8-bit data, low baud rate and to enable transmit, write 0b00100000 (or 0x20) to TXSTA
Bit 2 or BRGH can be used to select a higher baud rate (explained in the boxed below).                          ET1010 / ET0884 – Microcontroller Applications   Page 123 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  Higher Baud Rate    There are 2 ways to increase the baud rate of data transfer in the PIC18F4550: 1.  Use a higher-frequency crystal 2.  Set bit 2 (or BRGH) of the TXSTA register and use a different formula to compute the value to be put into SPBRG The new formula with BRGH = 1 is Desired Baud Rate = Fosc / [ 16 ( X + 1 ) ] The previous formula with default BRGH value of 0 is Desired Baud Rate = Fosc / [ 64 ( X + 1 ) ]                                         ET1010 / ET0884 – Microcontroller Applications   Page 124 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 8.3.5  RCSTA – receive status and control   This is an 8-bit register used to enable/disable the serial port, select 8-bit/9-bit data reception, enable/disable receiver, among other things.     Figure 8.10 – RCSTA register To enable the serial port, select 8-bit data, and enable receiver, write 0b10010000 (or 0x90) to RCSTA.     ET1010 / ET0884 – Microcontroller Applications   Page 125 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 8.3.6  PIR1 – peripheral interrupt request (flag) register 1     Two bits of the PIR1 register are used by USART - TXIF and RCIF
TXIF (transmit interrupt flag) == 1 indicates that the previous byte has been transmitted and a new byte can be written to the TXREG register
RCIF (receive interrupt flag) == 1 indicates that a new byte has been received and can be read from the RCREG register
Instead of polling, we can use interrupt
But this will not be discussed here
Figure 8.11 – PIR1 register                                ET1010 / ET0884 – Microcontroller Applications   Page 126 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________  // TRISCbits.TRISC6 = 0  1  // RCSTAbits.SPEN = // TXSTA = 0x20; // SPBRG = 77  The steps to transmit 8-bit data serially is as follows: i.e
Tx pin an tt Enable serial port Make RC6 of PORTC Set asynchronous mode, 8-bit data, low baud rate, & enable transmit
C-code for serial communication Set baud rate e.g
with 48 MHz 8.3  8.4.1  Programming the PIC18 to transmit data serially                                                TXIF == 1 i.e
previous byte transmitted? Still have data to transmit? Write byte to be transmitted to TXREG F yes yes no Figure 8.12 – Flowchart for serial transmission  ET1010 / ET0884 – Microcontroller Applications   Page 127 of 140 no continue elsewhere… [ control statement such as for, while can be used here… ] // TXREG = d // while (PIR1bits.TXIF == 0)  receiver. // RCSTA = 0x90; // TRISCbits.TRISC7 = 1  Make RC7 of PORTC i.e
Rx pin an input Enable serial port, 8-bit data, & enable The steps to receive 8-bit data serially is as follows: Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 8.3.7  Programming the PIC18 to receive data serially                                        continue elsewhere… [ control statement such as for, while can be used here… ] Set low baud rate. // TXSTA = 0x00; Set baud rate e.g
with 48 MHz Still expecting data? no RCIF == 1 i.e
entire byte received? // while (PIR1bits.RCIF == 0); F // SPBRG = 77  no yes yes Read byte received, from RCREG // data_in = RCREG;           Figure 8.13 – Flowchart for serial reception  ET1010 / ET0884 – Microcontroller Applications   Page 128 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 8.3.8  Programming the PIC18 to transmit & receive data serially   The following program continuously transmits data from an array (“data_out”) and receives data into another array (“data_in”)
A.  Write one byte to be transmitted to TXREG B.  Check if byte received C.  Read byte received from RCREG D.  Make RC6 i.e
Tx of PORT C an output pin E.  Set baud rate = 9600 F.  Enable serial port, 8-bit reception and enable receiver G.  Enable 8-bit transmission, select asynchronous mode & low baud rate H.  Make RC7 i.e
Rx of PORT C an input pin I.  Check if OK to transmit byte    TRISCbits.TRISC6 = 0;  // Configure Port C Pin 6 as a Digital Output (UART TX) TRISCbits.TRISC7 = 1;  // Configure Port C Pin 7 as a Digital Input pin (UART RX)                     RCSTA = 0x90;  // Configure UART Receiver TXSTA = 0x20;  //  Configure UART Transmitter SPBRG = 77;    //   Configure UART Baud rate to 9600 bps  t = 0; // t is index to array of data to be transmitted r = 0; // r is index to array for data received  while (1) { if (PIR1bits.TXIF == 1)  // Check if UART transmission has completed     {         TXREG = data_out [t];  // Transmit 1 byte on UART         t++;     } if (PIR1bits.RCIF == 1)  // Check if received 1 byte in UART buffer {         data_in [r] = RCREG; // Read 1 byte from UART receive buffer         r++;     }     // do other things here… }  ET1010 / ET0884 – Microcontroller Applications   Page 129 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 8.4  Review Questions  1.  What do you think the receiver must have to convert the serial data it receives  into 8-bit data that it usually handles?   2.  If even parity is used, what is the parity bit for the ASCII ‘A’ i.e
? 3.  Determine the value to write to the SPBRG register to configure the UART module to generate a baud rate of 9,600 assuming Fosc = 8 MHz  4.  How many times will the baud rate increase if BRGH = 1 assuming that the value in the SPBRG register remains unchanged?   ET1010 / ET0884 – Microcontroller Applications   Page 130 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 9 9.1  Introduction Introduction to Micro-controller Industry Applications    Today Microcontrollers are at the heart of the implementation of many industrial applications ranging from Aerospace, Automotive to more basic applications for household appliances form refrigerators and washing machines.  Modern industrial microcontroller applications, we are shifting away from “Single Microcontroller” to “Multi Microcontroller” implementations due to the rising complexities of these applications.   Typical use cases for such distributed embedded systems are in the Aviation and Automotive industries
The main driving factors are usually attributed to higher complexity and safety considerations required several microcontrollers to be deployed.  Also the latest trends in the industry are a shift to connected and intelligent devices linked by an ecosystem of smart IoT devices
At the heart of every IoT device is always a microcontroller or microprocessor interfaces to various sensors and actuators.  This chapter introduces several real world examples of how microcontrollers are used in industrial applications.                             ET1010 / ET0884 – Microcontroller Applications   Page 131 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 9.2  Microcontroller Applications in Industry  9.2.1  Automotive Industry  The modern automotive vehicle is essentially an Embedded Distributed System comprising of several ECUs (Electronic Control Units) each powered by at least 1 Microcontroller
Each ECU is then connected to 1 or more ECUs via a central vehicle bus implemented based on CAN, Ethernet or for older systems asynchronous communication serial buses such as UART or LIN.     9.2.2  Distributed Embedded System  Modern automotive vehicles support many different functionalities from safety critical ECUs controlling braking, powertrain to other ECUs controlling the door locking system, security system, headlight and turn lights, etc.  These functionalities are implemented and distributed across several ECUs with each ECU comprising a minimum of 1 microcontroller to several microcontrollers
Each microcontroller then runs its own software which then reads and controls any sensors and actuators that are directly connected to that particular ECU.  The different ECUs cannot function in isolation and needs to frequently communicate with other ECUs to read addition sensor information or to control actuators that are connected to that ECU
Each ECU is connected to other ECUs in the vehicle via the CAN bus or for higher speed communication via the Automotive Ethernet bus.   ET1010 / ET0884 – Microcontroller Applications   Page 132 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 9.3  Single ECU Embedded System  A single ECU implements a specific domain function, for example: there are dedicated ECUs implementing features for the car central locking and security system, exterior lighting systems for headlights, turn lights, brake lights, etc.  The diagram below illustrates a typical single ECU in an automotive vehicle and shows the typical Sensors and Actuators connected to the microcontroller for a “Body Controller” ECU.  In this ECU, the microcontroller is used to implement several functions that control actuators such as the car horn, headlights, signal turn lights, door locks and other devices.  Also for several of the functions that require data from other ECUs in the vehicle, the CAN bus is connected to the microcontroller which via a CAN Transceiver in the System Basis Chip (SBC).  The SBC is an external chip that is connected to the microcontroller via SPI (Serial Peripheral Interface)
SBC also contains a LIN transceiver, Watchdog and Voltage Regulator and all these devices in the SBC can be controlled and monitored via SPI by the microcontroller.  SPI is typically used in many embedded systems to communicate with on board ICs such as IO expanders, communication chips and many different peripherals as it required only 4 signals and is usually supported by most microcontrollers in hardware and software drivers.  Car Body Controller ECUSystem Basis Chip (SBC)Low Side DriverHornWatchdogCAN TransceiverLIN TransceiverVoltage RegulatorSPICANLIN5vDigital OutputMicrocontrollerSPIHigh Side DriverHeadlightsTurn LightsDoor LockCAN BusLIN BusLIN WiperDoor Control ECUInstrument Cluster ECUOther ECUs .
ET1010 / ET0884 – Microcontroller Applications    Page 133 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 9.4  Internet of Things – IoT  Internet of Things or simply IoT is a commonly accepted acronym today which basically describes electronic devices that have certain advanced features which typically allows for these IoT devices to be interconnected with other similar IoT devices.  In addition, IoT devices also usually incorporate various Sensors and Actuators that enable the IoT devices to sense the environment that they are deployed and to perform actions via visual indicators, or the actuation of motors, etc
Coffee Machine  Microcontrollers are used to implement the basic functions required for a coffee machine,  -  Basic Functions   IoT Functions -  o  Boiling of water and monitoring the water temperature o  Motor control of the coffee beans grinder o  Control and monitoring of the coffee machine using a smart phone o  Voice activated control of the coffee machine operations  ET1010 / ET0884 – Microcontroller Applications    Page 134 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 9.4.2  Trace Together Token   The Trace Together Token was developed by the Singapore Government is good example of a small embedded device that has very strict requirements for low power to conserve the battery life and keep the token operational continuously for a few months.  Basic components in the System Architecture of this device is shown below.  The “BLE System-On-Chip” or SoC is basically a microcontroller with additional built-in peripherals for BLE “Bluetooth Low Energy” communication.    9.5  Low Power Management  Today’s industrial applications usually integrate microcontrollers for applications that require reliable continuous long running operation
The management of the inactive mode of the microcontroller in low power mode is usually controlled by software to conserve the battery power.  Low Power Management implemented in Software typically involves the control of the microcontroller internal hardware peripherals to turn on only peripherals that are required to perform certain functionalities required for the industrial application to work.  For example, for automotive cars there is usually an ECU that implements the security and vehicle access functionality
The software running on this microcontroller has to periodically read all the door lock switches in a reduced or low power mode.    ET1010 / ET0884 – Microcontroller Applications   Page 135 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 9.5.1  Microcontroller Power Modes  Based on the example of an ARM Microcontroller, several different power modes are supported on the chip hardware level as shown in the diagram below.  The software controls the microcontroller power modes by executing special assembly instructions and setting dedicated Special Function Registers (SFRs).      In most embedded systems 2 main power modes are required,  -  High Power Mode  o  Microcontroller is in full power mode and most of its internal peripherals are clocked and active  o  Most of the software applications are running and active o In the ARM Microcontroller architecture, this corresponds to the “Active Mode” hardware power mode.   o  Microcontroller is in a reduced power mode and only essential internal -  Low Power Mode peripherals     o  The microcontroller could wake up periodically from its reduced power state and then re-enter reduced mode to save power o In the ARM microcontroller, this corresponds to several possible states depending on the low power current consumption required, eg: from “Sleep Mode” to “Hibernate Mode” which has the lowest current consumption  ET1010 / ET0884 – Microcontroller Applications   Page 136 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 9.6  Microcontroller Features in Industry Applications  9.6.1  Real Time Operating System (RTOS)  In our “Microcontroller Applications” module the software code runs in a single loop
This is known as “Bare Metal” software programming as there is no Operating System running and the software runs directly on the microcontroller with no Middleware layer.  However, in real world industrial applications, the software is much more running several in different time slices
This gives the illusion of the functions running in parallel but actually the software functions are sub divided into time slices which are then scheduled periodically.  Therefore, the real time requirements and high software complexity is usually then implemented via a Real Time Operating System (RTOS).   9.6.1.1 Basic RTOS “Round Robin” Scheduler  Most RTOS systems implement a basic scheduler that executes tasks or processes periodically and each task is assigned different priority levels as illustrated in the diagram below.            ET1010 / ET0884 – Microcontroller Applications   Page 137 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 9.6.1.2 RTOS Vendors  In the industry there are several vendors that implement RTOS with different license models
For Open Source free RTOS, “Free RTOS” is the most commonly used and has recently been acquired by Amazon and support IoT application development.  RTOS FreeRTOS Integrity  VxWorks  License MIT Open Source License Proprietary Closed Source Proprietary Closed Source Vendor Amazon GreenHills Wind River   9.7  Cyber Security  With today’s highly connected devices, Cyber Security and the secure storage and exchange of security sensitive data.  To support basic Cybersecurity requirements, the microcontroller has to support some of the following basic features,    -  AES 256 -  RSA 2048  -  Secure Storage o  Hardware support for Symmetric Cryptography o  Hardware support for Asymmetric Cryptography o  Storage of EEPROM data in a secure memory area with restricted access  - -  Random Number Generator  o  Hardware based Random Number Generator for generating random numbers used for random seeds for encryption, etc.  - -  Secure Boot o  Security protected bootloader to prevent hackers from starting insecure applications.          ET1010 / ET0884 – Microcontroller Applications   Page 138 of 140 Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 9.8  Multicore Microcontrollers  9.8.1  Amdahl’s Law  Due to the rapidly increasing computational power required by embedded system devices today, the trend is to have several CPU cores physically fabricated on a single silicon die in a microcontroller.  This means a single microcontroller has multiple cores and can execute instructions in parallel thus increasing the computational power.  Based on Amdahl’s Law, increasing the number of cores or processors nearly proportionally also increases the “Speedup” or computational processing power.    This trend for parallel processing to increase overall processing power throughput has led to the rise in popularity in Multi-Core Microcontrollers ranging from Dual Core devices up to Quad Core and higher number of CPU core microcontrollers.           ET1010 / ET0884 – Microcontroller Applications   Page 139 of 140  Microcontroller Applications - ET1010 / ET0884 Singapore Polytechnic ____________________________________________________________________ 9.9  Summary  In this chapter several examples of how microcontrollers are used in industry were explained
Microcontrollers are at the heart of every modern embedded system and these systems are getting increasing complex due to higher requirements in processing power, Cyber Security and Low Power considerations.  The current market trends and technical needs including the need for microcontrollers to run based on a Real Time Operating System (RTOS) was also explained in this chapter.  These real world industrial applications discussed in this chapter will help to give you a context and background in preparation for your Microcontroller Applications mini project for this module.                        ET1010 / ET0884 – Microcontroller Applications   Page 140 of 140 ET1010 / ET0884 - Microcontroller Applications - Tutorials Tutorial 1 - Introduction to Microcontrollers Q1.1 Which of the following best describes a microcontroller? (a) A microcontroller is any device that can provide intelligent control in a system(b) A microcontroller is small computer on a single integrated circuit consisting of a CPU,clock, timers, IO ports and memory.(c) A microcontroller is an integrated circuit with a fixed program running in it.(d) A microcontroller is a micro-processor.Q1.2 What is the correct sequence of a C IDE project build sequence? (a) Compiler  Pre-Processer Linker  Assembler(b)(c)(d)Pre-Processor  Compiler  Assembler  LinkerLinker  Compiler  Pre-Processor  AssemblerPre-Processor  Compiler  Linker  AssemblerQ1.3  Assuming Microcontroller A has a higher MIPS than Microcontroller B
What could be the possible result if same C code was compiled and executed on Microcontroller A and B? (a) Executable binary size is larger for Microcontroller A than B(b) Code executes faster on Microcontroller A than B(c) Code executes faster on Microcontroller B than A(d) Code requires more RAM on Microcontroller A than B Tutorial Page 1 of 16                             ET1010 / ET0884 - Microcontroller Applications - Tutorials Tutorial 2 - Microchip’s PIC18F4550 – An Overview Q2.1 Which of the following is an actuator device? (a) (b) (c) (d) Infra-Red (IR) sensor
Servo Motor Light Dependent Resistor (LDR)
Push button
Q2.2 The diagram below shows the “Smart Reading Lamp”
A PIC18 microcontroller is used for the implementation of an “intelligent reading lamp”
If it is dark (Brightness Sensor, B == 0) and human is detected (Human Sensor, H == 1), then the light will be switched on automatically (Light, L = 1)
The light will be off if it is bright (B == 1) or human is not detected (H == 0)
Manual override Button, M, is provided so that if M == 1, then the light will be turned on, regardless of the status of the Brightness Sensor or Human Sensor
In other words, the light will only depend on the sensors’ status when M == 0. (a)  Draw the system block diagram to show how the Brightness Sensor B, the Human Sensor H, the Manual Override Button M and the Light L can be connected the PIC18 microcontroller. (b)  Draw the flowchart for the intelligent control of the “Smart Reading Lamp” (c)  What suitable sensors can be used for the Brightness Sensor and the Human Sensor? (d)  Explain why is the brightness sensor mounted above the lamp shade?                 Tutorial Page 2 of 16                          ET1010 / ET0884 - Microcontroller Applications - Tutorials Tutorial 3 - PIC18F4550’s I/O Ports & Device Interfacing (Part 1) Q3-1.1 What is the expected result after the line of C code below has been executed? TRISB = 0b00001111; (a) (b) (c) (d) bits 7-4 are inputs, while bits 3-0 are outputs
bits 7-4 have been set to 0, while bits 3-0 have been set to 1
bits 7-4 are outputs, while bits 3-0 are inputs
bits 7-4 have been set to 1, while bits 3-0 have been set to 0
Q3-1.2 Based on the circuit diagram below, answer the following questions, a.  Is the switch connected as an Active High or Active Low input to the microcontroller? b.  When the switch is closed, what is the voltage level at microcontroller pin RD0? c.  Assuming that the LED has a voltage drop of 1.8 volts when turned ON, what is the current supplied by the microcontroller at output pin RD0? d.  Implement C code to fulfil the following requirements, -  When the switch  is closed, the LED shall be turned OFF -  When the switch is opened, the LED shall be turned ON                 Tutorial Page 3 of 16                  ET1010 / ET0884 - Microcontroller Applications - Tutorials Tutorial 3 - PIC18F4550’s I/O Ports & Device Interfacing (Part 2) Q3-2.1 A common cathode 7-segment display device is connected to PORTD (segment “a” to RD0, segment “b” to RD1..
decimal point to RD7)
Which of the following lines of C code will result in a digit “7” displayed on the 7-Segment display? (a)  PORTD  =  0b11100000; (b)  PORTD  =  0b00011111; (c)  PORTD  =  0b11111000; (d)  PORTD = 0b00000111; Q3-2.2 To monitor a potted plant soil, a moisture sensor (on the left) and a buzzer (on the right) are connected to a PIC18 microcontroller as shown below: When the soil is moist, the resistance of the sensor will be 0Ω
When the soil is dry, the resistance of the moisture sensor will be very high such that the resistance across points 1 and 2 can be approximated as an open circuit
a.  If the soil is dry, what logic value will the PIC18 microcontroller read at its RD0 pin? b.  To activate the buzzer, what is the logic level required at output pin RA1? c.  Complete the C code on the next page for the PIC18 microcontroller to turn on the buzzer when the soil is dry.                 Tutorial Page 4 of 16       ET1010 / ET0884 - Microcontroller Applications - Tutorials       1 2 3 4 5 6 7 8 9 10 11  12         main () { (i) (ii) (iii) // Configure RA0 and RA1 as Digital Inputs // Configure RA0 as input & RA1 as Digital Outputs { // Loop forever if (PORTDbits.RA0==1) (iv) else { (v)  // Turn off the buzzer  // Turn on the buzzer // Delay for 5 seconds here… PORTDbits.RA1 = 0; // Turn off the buzzer after 5 sec } // end of else // Delay for 30 minutes here… don’t check the soil too often } // end of while (vi) // end of main  Tutorial Page 5 of 16 ET1010 / ET0884 - Microcontroller Applications - Tutorials Tutorial 4 - PIC18F4550’s Analogue to Digital Conversion Q4.1 In a 10-bit ADC, the reference voltages are 5 V and 0 V
Estimate the digital result if the voltage at the analog input is 2 V. (a)  45010 (b)  41510 (c)  40910 (d)  40010 Q4.2
A sensor is used to monitor the water temperature in a fish tank, as follows: The temperature read by the sensor is converted into 10 bits Digital value by the internal ADC of the PIC18F4550 The format of the ADC result is right-justified and the converted digital value is then evaluated to control LEDs and Buzzer, according to the table below:                    Tutorial Page 6 of 16            ET1010 / ET0884 - Microcontroller Applications - Tutorials The C code running in the microcontroller is as follows: …… main (void) { // … other lines not shown  // configure A/D converter module & switch it on ADCON0 = ?? ADCON1 = ?? ADCON2 = ?? // select AN0 for conversion // use Vss (0V) as Vref-, and Vdd (5V) as Vref+ // right justify 10 bit result while (1) {     ?   // starts A/D conversion while (ADCON0bits.GO == 1); // wait here for A/D completion //  turn on LED & Buzzer, if temperature value not acceptable } } (a)  What value should be written to register ADCON to configure Analog pin AN0 as analog input channel? (b)  What value should be written to register ADCON1 in order to configure the ADC reference voltages to the following?   Vref- = Vss (0 v)   Vref+ = Vdd (5v) (c)  What value should bit 7 of ADCON2 be set to in order to right-justify the 10 bit conversion result? (d)  Write C code to start the A to D conversion. (e)  Write C code to turn on / off the LEDs & Buzzer, depending on the temperature.    Tutorial Page 7 of 16                         ET1010 / ET0884 - Microcontroller Applications - Tutorials Tutorial 5 - A Brief Revision on C Language Q5.1 Which of the following lines of C Code is implemented to detect the button press of an Active Low input connected to PIC18F4550 pin RB0? (a)  while (PORTBbits.RB0 == 0); (b)  while (PORTBbits.RB0 = 0); (c)  while (PORTBbits.RB0 = 1); (d)  while (PORTBbits.RB0 == 1); Q5.2 Which of the following lines of C-code shifts the value of the variable “count” by 2 bits? (a)  count = count + 2; (b)  count = count * 2; (c)  count = count << 2; (d)  count = count >> 2; Q5.3 Based on the C code below, unsigned char value_u8 = 0x54; a.  What is the number base format of the constant value used to initialize the variable “value_u8” ? Rewrite the code above to initialize the variable “value_u8” using C code representation for the following number bases, b.  Decimal c.  Binary Q5.4 Based on the C code below, what is the final value of the variable “output_u8” below after the code has been executed completely? unsigned char output_u8 = 0x40; output_u8 = output_u8 | 0x01;    Tutorial Page 8 of 16 ET1010 / ET0884 - Microcontroller Applications - Tutorials Tutorial 6 - PIC18F4550’s Programmable Timers / Counters Q6.1 Which one of the following applications certainly does not require a microcontroller with timer? (a)  Blinking an LED (b)  A real time clock (c)  A mechanical safe box (d)  Medicine dispenser Q6.2 In the C code below, what is the resultant Timer0 pre-scaler value? T0CON = 0b10000110; (a)  1/256 (b)  1/128 (c)  1/64 (d) 1/32 Q6.3 Assuming crystal oscillator with Fosc = 48 MHz is used as clock source and pre-scaler is not used, how long does it take for Timer0 (used as 16-bit timer) to count from 0x4000 to 0xFFFF & then roll over back to 0x0000? Q6.4 Assuming crystal oscillator with Fosc = 48 MHz is used as clock source and pre-scaler of 32 is used, what is the starting count value in order that exactly 0.1 sec has elapsed when timer overflows? Q6.5 A duration of a pulse signal that inputs to RB0 is to be measured using Timer0
The input signal and the C code implemented are shown below
Based on the Timer0 configuration used in the C code below, what are the resultant values written to the variables TempLow and TempHigh?                     Tutorial Page 9 of 16 ET1010 / ET0884 - Microcontroller Applications - Tutorials … T0CON = 0b10000100; // Timer 0 on, 16-bit, Fosc/4, pre-scaler 32 while (PORTBbits.RB0 == 0);  // wait for signal at RB0 to go high  TMR0H = 0x00; TMR0L = 0x00;  while (PORTBbits.RB0 == 1);  // wait for signal at RB0 to go low T0CONbits.TMR0ON = 0; // stop Timer 0 TempLow = TMR0L; TempHigh = TMR0H; …  Q6.6 A PWM signal is shown below
Calculate the duty cycle of the signal. (Please note that the figure is not drawn to the scale.)         14 ms 120 ms    Tutorial Page 10 of 16 ET1010 / ET0884 - Microcontroller Applications - Tutorials Q6.7 Based on the C code below, If a PWM signal is used for controlling a DC motor speed, what is achieved with following C code? Fill out all the missing comments in the code below.     //…………………………………………………………………. …… TRISCbits.TRISC2 = 0; CCP1CON = 0b00001100;  // ………………………………………………………………… TMR2 = 0; // …………………………………………………………………  T2CON = 0b00000110; PR2 = 149; //………………………………………………………………….. //………………………………………………………………....
while (1) { } ….
CCPR1L = 74; delay_ms(500); CCPR1L = 25; delay_ms(500); //…………………………………………………………………… //…………………………………………………………………….    Tutorial Page 11 of 16                  ET1010 / ET0884 - Microcontroller Applications - Tutorials Tutorial 7 - PIC18F4550’s Interrupt Q7.1 Which one of the following applications requires use of interrupts for a reliable operation? (a)  Obstacle avoiding robot (b)  Auto-plant watering device (c)  Room temperature control (d)  Medicine dispenser Q7.2 INTEDG0 bit of INTCON2 register . (a)  selects internal or external interrupt (b)  selects interrupt priority (c)  selects interrupt to occur at falling or raising edge (d)  none of these Q7.3 Which one of the following is not an interrupt source in PIC18F4550? (a)  All the timers (b)  Any change in PORTB pins (c)  When RAM memory is full (d)  ADC Q7.4 Observe the following lines of C code and fill out the missing comments
INTCONbits.GIEH = 1; //………………………?………………………… INTCONbits.TMR0IE = 1;  //………………………?………………………… Q7.5 A Timer0 interrupt is to be implemented
Write the appropriate C statements for the task, with following Timer0 setting: initialise Timer0 with value 0x4F28 (i)  Timer0 in 16 bit operation, pre-scale value of 1:8 (ii) (iii)  enable Global Interrupt and Timer0 interrupt (iv)  clear Timer0 overflow flag    Tutorial Page 12 of 16 ET1010 / ET0884 - Microcontroller Applications - Tutorials Q7.6 For a PIC18F4550 to have pin RB0 as an interrupt-input, write C Code for the following operations based on the comments for each line of code below. ; // (i)  Configure RB0 as input ; // (ii)  Interrupt on rising edge of signal at RB0 ; // (iii) Enable Global Interrupt ; // (iv) Enable INT0 external interrupt ; // (v) Enable priority levels on interrupts ; // (vi) Clearing interrupt flag Q7.7 The following circuit diagram shows interface circuits and connections made to a PIC18F4550 microcontroller
The C code is developed using polling technique. (i)  Analyse the C code on the next page and explain what the software is attempting to achieve? (ii)  What are the possible issues with the implementation of the C code? (iii)  Rewrite the C code to replace the polling with interrupts instead.                Tutorial Page 13 of 16 ET1010 / ET0884 - Microcontroller Applications - Tutorials #include <xc.h> #include "delays.h" unsigned char press; void main(void) { unsigned char TL; unsigned char TH; TRISC=0x00; TRISD=0x00; TRISB=0x0F; T0CON = 0b10000100; // configure timer0 T2CON=0b00000111;  //  configure  timer2 CCP1CON=0b00001100; PR2 = 149; CCPR1L = 75; press==0; // 50% duty cycle by default while(1) { if(PORTBbits.RB0==0) { press++; if (press==1) { CCPR1L = 37; } else if (press==2) { CCPR1L = 120; press=0; } } while (PORTBbits.RB1 == 1); TMR0H = 0x00; TMR0L = 0x00; T0CONbits.TMR0ON = 1; while (PORTBbits.RB1 == 0); T0CONbits.TMR0ON = 0; TL = TMR0L; TH = TMR0H; // read TMR0L first         Tutorial Page 14 of 16 if (TH > 0x20) { PORTD=TH; delay_ms(500); PORTD=0x00; // display TMR0H content } } }                      ET1010 / ET0884 - Microcontroller Applications - Tutorials Tutorial 8 - PIC18F4550’s Serial Port Q8.1 Which of the following is used to receive a byte of data serially in PIC18F4550? (a)  data_in = TXREG; (b)  data_in = RCREG; (c)  SPBRG = 77; (d)  PIR1bits.RCIF == 1; Q8.2 For a PIC18F4550 microcontroller with an oscillator frequency of 48 MHz, calculate the value for SPRBG register in order to communicate at a baud rate of 19200
Q8.3 The code below is implemented to transmit data via serial communication port of PIC18F4550 to an external device
Explain the purpose of code on lines (1), (2) and (3). …… unsigned char data; … data = D2+0x30; // Line (1) while (PIR1bits.TXIF == 0);  // Line (2) TXREG = data; delay_ms(100); … // Line (3) Q8.4  Refer to the serial communication signal captured on an oscilloscope screen
a.  What would be the descriptions for A, B, C and D? b.  In hexadecimal, what is the 1 byte of data being sent? A B C D    Tutorial Page 15 of 16        ET1010 / ET0884 - Microcontroller Applications - Tutorials Q8.5 Fill out the missing C code below to communicate with a sensor connected to PIC18 based on UART Serial Communication
while(1) { ……………………………. // send command 0x50 to smart sensor ……………………………. // wait for receive flag to be set ……………………………. // receive sensor data and keep in variable temp …. }    Tutorial Page 16 of 16 MAPP  ____________________________________________________________________ © 2016 Lab 1 – Introduction to PIC18F4550 Board, MPLABX-IDE, C-compiler and USB downloader
Objectives To illustrate the procedures to create a Microchip’s PIC micro-controllerproject in MPLABX IDE, and to create, edit and compile a C programusing XC8.To show the steps to setup the USB link with the PIC18F4550 micro-controller, and to download a program to the micro-controller and toexecute it.Introduction / Briefing      At the beginning of each lab session, your lab lecturer will go through ashort briefing before you begin the experiment.The discussion will help you in the MST, the lab test as well as theproject
So, please pay attention and participate in the discussion.This lab sheet contains many screen captures to show you how to createa project, how to create, edit and compile a C program, and how todownload a program to the micro-controller and run it
In subsequent labs,if you forget certain steps, you should refer to this lab sheet again.To do this lab, the software tools required must already be installed onthe PC.PIC18F4550 I/O ports You will learn more about the I/O ports in Chapter 3
The following is abrief summary.PIC18F4550 has five I/O ports: A to E
Many pins have multiple functions.For instance, pin 14 is RA6 (Port A Pin 6) and also OSC2 (oscillator input2).Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 1 of 24 MAPP  ____________________________________________________________________ © 2016 Port A The table below shows which pins can be used as general purpose I/Opins and whether they are, by default (i.e
after power on reset),analogue or digital, input or output.Port Available pins Not available as general purpose I/O ( - reasons ) After power on reset A B C D E RA6-0 RA6 ( – oscillator ) RB7-0 RB4 ( – “Boot” button ) RA5, 3-0: Analogue inputs (*)
RA4: Digital input
RB4-0: Digital / Analogue inputs (#)
RB7-5: Digital inputs
RC7-4, 2-0  RC5-4 ( – USB connector ) RC7-4, 2-0: Digital inputs
RD7-0 RD7-0: Digital inputs
RE3-0 RE3 ( – “Reset” button ) RE2-0: Analogue inputs (*)
RE3: Digital input. (*) ADC (Analogue to Digital Conversion) will be discussed in details in the future. (#) For the PIC18 chips used in the labs, RB4-0 are Digital inputs after power on reset. This lab will only involve ports B and D.Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 2 of 24 MAPP  ____________________________________________________________________ © 2016 Port configuration Do you know why the switches connected to RB0-2 are “active low”?Do you know why the LED’s connected to RD0-2 are “active high”?To use port B to read the switch status (open or closed), port B must beconfigured as digital inputs.Referring to the table above, RB4-0 are digital inputs after reset.To use port D to control the LEDs (on or off), port D must be configuredas digital outputs.But, RD7-0 are digital inputs after reset.The command below must be added to change them into digital outputs:TRISD = 0b00000000; Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 3 of 24 MAPP  ____________________________________________________________________ © 2016 TRISD is the “data directional register” for Port D.By writing a 0 into a particular TRISD bit, the corresponding PORTD pinbecome an Output pin.TRISD 7 0 6 0 5 0 4 0 3 0 2 0 1 0 0 0 RD0 PORTD  Output  Output  Output  Output  Output  Output  Output  Output RD6 RD7 RD5 RD4 RD3 RD2 RD1 Likewise, by writing a 1 into a particular TRISD bit, the correspondingPORTD pin can become an Input pin.Looping forever After configuring Port B as digital input and Port D as digital output, thewhile (1) loop below will be executed over and over: while (1)  {  data = PORTB;  // switch status is copied into a variable called DATA  PORTD = data;  // and used to turn on/off the LEDs   } PORTB (monitor status of switches i.e
open or closed)DATA (unsigned char, a 8-bit variable) PORTD (control status of LEDs, i.e
on or off)Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 4 of 24 MAPP  ____________________________________________________________________ © 2016 Activites: 1.2.Before the beginning of each lab lesson, double click on the MAPP icon onthe desktop
This will delete the files modified by other students beforeyou and replace them with fresh copies
The (.c & project) files used in allthe experiments will be stored in a folder named ProjectX in the D:\Drive.Double click on the MPLABX IDE icon on the desktop to launch thesoftware.Creating a Microchip’s PIC micro-controller project in MPLABX-IDE 3.Click File -> New Project … to create a new project.Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 5 of 24 MAPP  ____________________________________________________________________ 4.You will see the New Project window.We will use the default setting Microchip Embedded – Standalone Project.Click Next.Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 6 of 24 MAPP  ____________________________________________________________________  5.Select PIC18F4550 as the Device (i.e
the microcontroller) to use forthis project. [Hint: You can type the number 4550 to filter down the list.]Then, click Next.6.We are not using any debugging tools, so just click Next.Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 7 of 24 MAPP  ____________________________________________________________________  7.Select the XC8 Compiler as follows and click Next.8.Browse to the Project Location as follows and enter the Project Name:Project Name  Project Location  : Lab1: D:\ProjectXThen, click Finish
Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 8 of 24 MAPP  ____________________________________________________________________  9.Set the Codeoffset to 1000 as follows.The microcontroller that we are using already has a program in the ROMcalled the bootloader
It is used for communicating with a program in thePC using the USB ports
The bootloader in the ROM occupies thelocations from 0x0000 to 0x0FFF
The user program for themicrocontroller must therefore starts from location 0x1000.  To do this,we must set the Codeoffset to 1000.Click File -> Project Properties (Lab1):Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 9 of 24 MAPP  ____________________________________________________________________  10.You will see the Project Properties – Lab 1 window:Click XC8 linker
Then in Option categories, select Additional options.And enter 1000 for Codeoffset and then click OK.100011.You will see a summary of the project Lab1 that you have just created.At this point, a new project has been created but there are no files
Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 10 of 24 MAPP  ____________________________________________________________________  Creating, editing and compiling a C-program using XC8 In the next few steps, you will add a new C source file, and edit it
Youwill then compile the C program.12.To add a new file, right click on Source Files -> New -> main.cFor this lab, we will use the default File Name: newmain and default Extension: c
So click Finish
Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 11 of 24 MAPP  ____________________________________________________________________  13.The c file generated by the compiler has a brief description and an emptymain() function:14.Add the lines as shown on the right to newmain.c.Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 12 of 24 MAPP  ____________________________________________________________________  15
What the program is doing? Look at the comments for an explanation.TRISB = 0b11111111;// PORTB is configured as all inputs TRISD = 0b00000000;// PORTD is configured as // all outputs while (1) {    // repeat forever the code below     data = PORTB; // read the inputs from PORTB // and save in data     PORTD = data; // output the data to PORTD } 16.In the Projects tab, click on the [+] next to Source Files to expand it
Youshould be able to see newmain.c under Source Files:Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 13 of 24 MAPP  ____________________________________________________________________  17.The file newmain.c is found in the folder D:\ProjectX\Lab1.X folder:18.Let’s build the project with a Hammer!Method 1 : Run -> Build Method 2: Click Hammer
Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 14 of 24 MAPP ____________________________________________________________________  19.If there are no errors, you will see BUILD SUCCESSFUL.If there are errors, click on the error message and that will lead to the program line that has the error
After correcting the error, try to build again
20.You can see the machine code/hex file Lab1.X.production.hex has beencreated.Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 15 of 24 MAPP ____________________________________________________________________  21.Using window explorer (my computer), browse to the folderD:\ProjectX\Lab1.X\dist\default\production and you should be able tosee that hex file:At this point, a C program (newmain.c which was created earlier) has been compiled into the hex code Lab1.X.production.hex
This is a machine code version of the newmain.c which must be downloaded to the microcontroller for it to be executed
Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 16 of 24 MAPP ____________________________________________________________________  Downloading a program (a hex file) to the micro-controller and executing it
22.23.Connect the PIC18F4550 board to the PC’s USB port using the USB cableprovided.Double click on the HIDBootloader  icon on the desktop to launch thesoftware.24.On the PIC18F4550 board, press & hold the Boot button, press and thenrelease the Reset button, and finally release the Boot button.Reset 2
Press3
releaseBoot 1
Press4
releaseLab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 17 of 24 MAPP  ____________________________________________________________________  25.The USB Bootloader software will automatically detect the PIC18F4550board and the message “Device Ready” will be shown:26.Click File -> Import Firmware Image and select the HEX file that wasjust created, Lab1.X.production.hex.Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 18 of 24 MAPP ____________________________________________________________________  27.Click Open and the status will be updated as shown.28.Click Program Device to program the micro-controller.1
ImportFirmware2 Program 3
ResetThis diagram summaries the three steps needed to download a program
29.Click Reset on the USB Bootloader software or pressing the Reset buttonon the PIC18F4550 board will run the program in the micro-controller.Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 19 of 24 MAPP ____________________________________________________________________  30.31.Can you see the LED’s (connected to RD2, RD1 and RD0) light up?Press the buttons connected RB2, RB1 and RB0 one by one
What is theeffect of pressing a button?Your answer: ________________________________________  At the end of each lab, there is an Extra Exercise for those who finishearly
Doing this Extra Exercise allows you to learn more about micro-controller.Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader  Page 20 of 24 MAPP  ____________________________________________________________________  Extra Exercise In this exercise, you will modify the C-program to light up the LED’s oneby one.32.Modify the C program to the following.#include <xc.h> void main(void) {  TRISB = 0b11111111;    TRISD = 0b00000000;  while (1) { // repeat PORTD = 0b00000001;  // turn on LED in RD0  // delay for 500ms delay_ms(500); PORTD = 0b00000010; // turn on LED in RD1 delay_ms(500);       // delay for 500ms PORTD = 0b00000100; // turn on LED in RD2  // delay for 500ms  delay_ms(500);          } return; } 33.Build the program and is it successful?Your answer: _________________34.The error is because the compiler does not know what the functiondelay_ms(500) is
We need to add in the files delays.h to the HeaderFiles and delays_utilities.c to the Source files of the project, as follows.Right click on Header Files -> Add Existing Item…Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader Page 21 of 24 MAPP ____________________________________________________________________  35.In the Select Item window that appears, browse to the folderD:\ProjectX\Utilities and select the file delays.h (the extension may notappear).Click Copy to get a copy of this file and then click Select.36.The file delays.h is now added to the Header Files
Next, add the filedelays_utilities.c to the Source Files
After this, you should see:Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader  Page 22 of 24 MAPP ____________________________________________________________________  37
We also need to add the #include “delays.h” statement to the C program.Build the project again and it should be successful
Download this program to the board and the LEDs should be lighting up one at a time with a delay of about half a second
38.Try to slow down the rate of blinking by increasing the delays. (Hint:change all the values 500 to 1000).Rebuild and download the program.39.Then, make the LEDs blink faster and faster until it stops blinking.Rebuild and download the program.40.Finally, make the LEDs blink together by turn on and off all three LEDsat the same time
Use any reasonable delay of your choice.Rebuild and download the program.Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader  Page 23 of 24 MAPP  ____________________________________________________________________ // file : delays.h #define _XTAL_FREQ 48000000 extern void delay_ms(unsigned int i);  // delay in milli-secs, up to  //max 65535 ms extern void delay_us(unsigned int i);  // delay in micro-secs, up to //max 65535 us /* * File:   delays_utilities.c** Created on 13 January, 2016, 1:31 PM */ #include <xc.h> #define _XTAL_FREQ 48000000 void delay_ms(unsigned int i) { unsigned int j; if(i!=0)  // check for i=0 for(j=0;j<i;j++)__delay_ms(1); // call __delay_ms(1) x i times } // this delay is too short to be accurate - good luck
void delay_us(unsigned int i) { return; // too short no delay unsigned int j,lower; // for micro sec, the looping takes too long // so split into two parts, 20 seems to work fine lower = i; lower = lower/20; if (i< 5) {  }else if (i<10) { } else if (i< 20) { } else       for(j=0;j<lower;j++)__delay_us(20); __delay_us(15); // delay is 10-19 __delay_us(7); // delay is 5 to 9 so just pick 7 } Lab 1 – Intro
to PIC Board, MPLABX-IDE, C-compiler and USB downloader  Page 24 of 24 MAPP  ____________________________________________________________________  Lab 2 – Interfacing to switches and LED’s Objectives To learn to configure PIC18F4550’s I/O ports as inputs or outputs.To learn to read status of switches – open or closed.To learn to turn on / off a number of LED’s, in various sequences.To learn to use the delay functions.Introduction / Briefing Switches at Port A In this experiment, you will be reading the status of the dip switchesconnected to Port A.Below are the ways in which the switches are named and used in software
Switch at RA3 has the name PORTAbits.RA3 Switch at RA4 has the name PORTAbits.RA4 Switch at RA5 has the name PORTAbits.RA5 PORTA on its own refers to all 8 bits and not individual bits
Lab 2 – Interfacing to switches and LED’s Page 1 of 12 MAPP  ____________________________________________________________________  Study the above diagram and answer the following questions:Q1:  How many dip switches are there? __________ Q2:  How many are connected to Port A? __________ Q3:  What is the purpose of the 470 ohm resistors? _______________________________________________________ (The above is a tough question
Hint: imagine someone making the mistake of configuring Port A as output AND producing a logic ‘1’ at one of RA3:RA5 AND the corresponding dip switch is closed.) Q4:  Are the switches connected in the “active high” or “active low” manner? (An “active high” switch gives a logic ‘1’ when closed.) ____________________ Q5:  What will a Port A pin read (logic ‘1’ or ‘0’) when a corresponding dip switch is closed? __________ To allow Port A to read the dip switches, it must be configured as adigital input port
However, Port A is a partially analogue/partially digitalinput port by default (after power on reset):[ Refer to the “insert” on the next page to understand the last column. ]Port Available pins Not available as general purpose I/O ( - reasons ) After power on reset A RA6-0 RA6 ( – oscillator ) RA5, 3-0: Analogue inputs (*)
RA4: Digital input
Q6:  Give the C-command to configure Port A as a digital input port (hint: ADCON1): ______________________________ // configure Port A as digital inp
Lab 2 – Interfacing to switches and LED’s Page 2 of 12 MAPP ____________________________________________________________________  When a dip switch is closed, the corresponding Port A pin will read a logic‘0’.Q7:  Give the C-command to check if the dip switch connected to RA3 is closed (hint: PORTA): if ____________________ // if dip switch @ RA3 is closed { // do something } Lab 2 – Interfacing to switches and LED’s Page 3 of 12 MAPP ____________________________________________________________________  LED bar at Port D In this experiment, you will also be turning on and off an LED barconnected to Port D.Study the above diagram and answer the following questions:Q8:  How many LED’s are there in the LED bar? __________ Q9:  How many are connected to Port D? __________ Q10:  What is the purpose of the 470 ohm resistors in the SIP (Single-In-Line package)? ______________________________ Q11:  Are the LED’s connected in the “common anode” or “common cathode” manner? ____________________ Q12:  What must a Port D pin produce (logic ‘1’ or ‘0’) to turn on a corresponding LED? __________ Lab 2 – Interfacing to switches and LED’s Page 4 of 12 MAPP  ____________________________________________________________________  To allow Port D to control the LED bar, it must be configured as a digitaloutput port
However, Port D is a digital input port by default (afterpower on reset):Port Available pins Not available as general purpose I/O ( - reasons ) After power on reset D RD7-0 RD7-0: Digital inputs
Q13:  Give the C-command to configure Port D as a digital output port (hint: TRISD): _____________________________ // configure Port D as digital outp. To turn on a particular LED, the corresponding Port D pin must produce alogic ‘1’.Q14:  Give the C-command to turn on the LED’s as follows (hint: PORTD): ON ______________________________ // turn alternate LED’s on Lab 2 – Interfacing to switches and LED’s Page 5 of 12 MAPP  ____________________________________________________________________  Activities: Using LEDs to indicate switch status Create a New Project – Lab2 1.Launch the MPLABX IDE and create a new project called Lab2.Below is a summary of the steps needed or you can refer to Lab1.6d
Codeoffset      1000 Lab 2 – Interfacing to switches and LED’s Page 6 of 12 MAPP  ____________________________________________________________________  2.Use “Add Existing Item” to add the file OnOffLeds.c to the Lab2project Source File folder, as follows
Make sure Copy is tickedbefore you click Select.3.Double click on Source Files – OnOffLeds.c to look at the program.// OnOffLeds.c // Program to use switches to control 8 leds on General I/O Board #include <xc.h> void main(void) {  ADCON1 = 0x0F; //make Port A digital  TRISA = 0b11111111; //RA5 to RA3 are connected to On/Off switches  TRISD = 0b00000000; //RD7 to RD0 are connected to LEDs  while (1) //repeat     {         if (PORTAbits.RA3 == 0) //_____________________         {         }         else         {  PORTD = 0xF0;     // PORTD = 0b______________________  PORTD = 0x0F;     // PORTD = 0b______________________  }} } 4.Describe what this program will do:____________________________________________________________________________________________________Lab 2 – Interfacing to switches and LED’s Page 7 of 12 MAPP  ____________________________________________________________________  5.6.7.Build, download and execute the program
Observe the result and see if itis as expected.Change the program to use the switch at RA5, such that if RA5 is on, allthe LEDs should be on and if RA5 is off, all the LEDs should be off.Build, download and execute the program
Observe the result and see if itis as expected.LED’s blinking / ”scanning” Use delays, toggle LED’s.  8
Right click on OnOffLeds.c and click “Remove From Project”
Then addthe file  BlinkLeds.c to the project. (“Remove From Project” only removesthe file from the project, it is not deleted.)9.Study the code and describe what this program will do:__________________________________________________Note that the program uses the delay function delay_ms() and contains#include “delays.h”
The file delays.h needs to be added to Header Fileswhile the file delays_utilities.c needs to be added to Source Files.Build, download and execute the program
Observe the result and see if itis as expected.10.11.Pause an action  12.Add the following line to the while(1) loop:while(1){while (PORTAbits.RA3 == 0); // loop here when switch is on PORTD=0b10101010; ……. // other existing lines – don’t touch } 13.Describe what this NEW program will do:__________________________________________________14.Build, download and execute the program
Observe the result and see if itis as expected.Lab 2 – Interfacing to switches and LED’s Page 8 of 12 MAPP ____________________________________________________________________  Right to left “scan”  15
Modify the program to do “scanning”, such that one LED light repeatedlymoves from right to left (after a short delay).Add in a switch control line such that when the switch connected to RA3is closed, the “scanning” is paused.Pause  the  16.“scan” 2-way“scan”17.Debug until the program can work. 18
Modify the program to do a “right to left scan”, followed by a “left toright scan” repeatedly
Include the switch control line to pause thescanning with a closed switch at RA3.19.Debug until the program can work.Slow down the “scan”  20.Modify the program such that a closed switch at RA4 slows down thescanning (while a closed switch at RA3 pauses the scanning). (Hint: adddelay if switch at RA4 is closed.)21.Debug until the program can work.Lab 2 – Interfacing to switches and LED’s Page 9 of 12 MAPP  ____________________________________________________________________  LED’s “counting” Counting Replace BlinkLeds.c with CountLeds.c. 22
23.Study the code and describe what this program will do:__________________________________________________24.Build, download and execute the program
Observe the result and see if itis as expected.Counting Up/down  25.Modify the program such that a closed switch at RA5 causes counting upwhile an opened switch causes counting down
Here are some hints:while (1){else }  ….. // other lines unchanged if (PORTAbits.RA5 == 0) // if switch is closed ____________________ // count up ____________________ // count down Slow down the counting  26
Add in a line such that a closed switch at RA4 slows down the counting.Pause the counting 27. Add in another line such that a closed switch at RA3 pauses the counting.28.Debug until the program can work.Lab 2 – Interfacing to switches and LED’s Page 10 of 12 MAPP ____________________________________________________________________  Extra Exercise 29.A left-shift is equivalent to multiplication by 2 while a right-shift isequivalent to division by 2.If you still have time at the end of this Lab, try to write a LED scanningprogram (you can modify any existing file – OnOffLeds.c or BlinkLeds.c orCountLeds.c) such that the scanning is normally from right to left, but2-wayscan, with pausing & slowing down   30.A closed switch at RA5 causes a left to right scan.A closed switch at RA4 causes scanning to slow down.A closed switch at RA3 causes scanning to pause.31.Debug until the program can work.// OnOffLeds.c // Program to use 1 switch to control 8 leds on General I/O Board #include <xc.h> void main(void) { ADCON1 = 0x0F;       //make Port A digital TRISA = 0b11111111; //RA5 to RA3 are connected to On/Off switches TRISD = 0b00000000; //RD7 to RD0 are connected to LEDs while (1) //repeat  if (PORTAbits.RA3 == 0) //_____________________ PORTD = 0xF0;     // PORTD = 0b______________________ PORTD = 0x0F;     // PORTD = 0b______________________     {         {  }         else         {         }     } } Lab 2 – Interfacing to switches and LED’s Page 11 of 12  MAPP  ____________________________________________________________________ // BlinkLeds.c // Program to light up alternate leds on General I/O Board #include <xc.h> #include "delays.h" void main(void) {     ADCON1 = 0x0F     ; //make Port A digital TRISA = 0b11111111; //RA5 to RA3 are connected to On/Off switches TRISD = 0b00000000; //RD7 to RD0 are connected to LEDs while (1) //repeat     {         PORTD = 0b10101010;         delay_ms(1000);    PORTD = 0b01010101;         delay_ms(1000);     } } // CountLeds.c // Program to make 8 leds on General I/O Board do binary up counting #include <xc.h> #include "delays.h" unsigned char j;  // 8 bit data type, range 0 to 255 void main(void) { //make Port A digital ADCON1 = 0x0F; TRISA=0b11111111; //RA5 to RA3 are connected to On/Off switches TRISD=0b00000000; //RD7 to RD0 are connected to LEDs j=0; while(1) { //beginning //repeat PORTD = j; // Output value of j to PORTD     delay_ms(500); j++; // Increment j } } Lab 2 – Interfacing to switches and LED’s Page 12 of 12 MAPP  ____________________________________________________________________  Lab 3 – Interfacing to 7-segment displays and buzzer Objectives To learn to display a decimal number on a 7-segment display.To learn to use multiplexing technique to display several digits on several7-segment displays.To learn to implement a “queue number system”.To learn to produce a tone on a buzzer.Introduction / Briefing 7-segment display at Ports B & DIn this experiment, you will be turning on and off segments in four 7-segment displays connected to Ports B & D, to display some numbers.Lab 3 – Interfacing to 7-segment displays and buzzer Page 1 of 16 MAPP ____________________________________________________________________  Considering only one 7-segment display (shown below) and answer thefollowing questions:PIC18F4550 Digital output port RD0 RD1 RD2 RD6 RD7 5 V 7-segmentdisplayCOMMON A B C G dp Common anode Cathodes F E A G D B C dp How it looks Q1:  Are the LED’s in the 7-segment display connected in the “common anode” mode or the “common cathode” mode? ____________________ Q2:  What must RD0 produce (logic ‘0’ or logic ‘1’) to turn on segment A? __________ Q3:  What must PORT D produce (in binary format) to show the digit “1” on the 7-segment display? PORTD = 0b                
Q4:  Of course, PORT D must be configured as an output port
Give the 2-line C command to configure PORT D as a digital output port and to show the digit “5” on the 7-segment display: TRISD = 0b____________________ // configure Port D as digital outp
PORTD = 0b______________________ // display “5” Lab 3 – Interfacing to 7-segment displays and buzzer Page 2 of 16 MAPP ____________________________________________________________________  Considering four 7-segment displays together (shown below) and answerthe following questions:  Digital output ports RB0 RB1 RB2 RB3 RD0 RD1 RD2 RD6 RD7 7-segment displaysDIG3 COMMON DIG2 DIG1 DIG0 A B C G dp  PIC18F4550 Common anode Cathodes F E A G D B F C E dp A G D B F C E dp A G D B F C E dp A G D B C dp Q5:  What will be shown on the 7-segment displays if PORT D outputs 0b01001111 while PORT B outputs 1000 to its lower 4 bits? DIG3 shows _____ DIG2 shows _____ DIG1 shows _____ DIG0 shows _____ Lab 3 – Interfacing to 7-segment displays and buzzer Page 3 of 16 MAPP ____________________________________________________________________  Q6:  What must PORT B and PORT D produce to show 2 on DIG2? PORT D = 0b ________ PORTBbits.RB3 = _____ PORTBbits.RB2 = _____ PORTBbits.RB1 = _____ PORTBbits.RB0 = _____ Q7:  What will be shown on the 7-segment displays if following C program is run? TRISB = 0b11110000; TRISD = 0b00000000; // lower 4 bits are outputs // all bits are outputs while (1) { PORTB = 0b00000001; PORTD = 0b00111111; // Some delay PORTB = 0b00000010; PORTD = 0b00000110; // Some delay PORTB = 0b00000100; PORTD = 0b01011011; // Some delay PORTB = 0b00001000; PORTD = 0b01001111; // Some delay } // enable DIG0 // display 0 // enable DIG1 // display 1 // enable DIG2 // display 2 // enable DIG3 // display 3 Your answer:_____________________________________________ _______________________________________________________ Q8:  What do you think will happen if the delay is increased? Your answer: _______________________________________________ Lab 3 – Interfacing to 7-segment displays and buzzer Page 4 of 16 MAPP  ____________________________________________________________________  Q9:  What do you think will happen if the delay is decreased? Your answer: _______________________________________________ You will find out the answer to the two previous questions in the experiment
Buzzer at Port C In this experiment, you will also be turning on and off a buzzer connectedto PORT C to produce a “tone”.low pitch tone high pitch tone Study the above diagram and answer the following questions:Q10:  What happens when RC0 outputs logic ‘1’? The transistor is turned on and ( assuming VCE[sat] = 0.2V, ) pin 2 of the Buzzer is at _____ V while pin 1 of the Buzzer is at _____ V
So the Buzzer will be turned _____
If RC0 outputs logic ‘0’, the Buzzer will be turned _____. By toggling ( on -> off -> on -> off …. ) RC0 continuously, a tone can be produced by the buzzer
If the rate of toggling is high, a high pitch tone is produced.Lab 3 – Interfacing to 7-segment displays and buzzer Page 5 of 16 MAPP ____________________________________________________________________  Activites: Before you begin, ensure that the Micro-controller Board is connected to the General I/O Board
The General I/O Board is further connected to a 7-Segment/Switch Board
PORTD – 8 segments (‘a’ to ‘g’, and decimal point) of all 4 digits, active high (‘1’ turns on a segment, ‘0’ turns off a segment)
PORTB – RB0 to RB3 – COM pins of all 4 digits (DIG0 to DIG3), active high (‘1’ enables digit, ‘0’ disables digit)
PORTB – RB5 – push button switch, active low (pressed gives ‘0’, released gives ‘1’)
So PORTD controls the number e.g. ‘8’ to be displayed on a digit, while PORTB controls which digit displays the number
Displaying a decimal number on a 7-segment display 1.Launch the MPLABX IDE and create a new project called Lab3.Display “0” on DIG0
Display “1” on DIG1
2.  Add the file Single7Seg.c to the Lab3 project Source File folder.Make sure Copy is ticked before you click Select
If you have forgottenthe steps, you will need to refer to the previous lab sheet.3.Study the code and describe what this program will do:__________________________________________________4.Build, download and execute the program
Observe the result and see if itis as expected. 5
Modify the code to display the digit “1” on the next 7-segment i.e
DIG1.Build, download and execute the program to verify your coding.6.Describe what will happen when PORTB = 0b00001111
Why?Answer: _____________________________________________Lab 3 – Interfacing to 7-segment displays and buzzer Page 6 of 16 Display 4 decimal numbers on four 7-seg.’s Increase delay Decrease delay MAPP  ____________________________________________________________________  Displaying 4 different decimal numbers on four 7-segment displays  7
Replace Single7Seg.c with Four7Seg.c
Note that the program uses thedelay function delay_ms() and contains #include “delays.h”
The filesdelays.h and delays_utilities.c need to be added to the Project.8.Study the code and describe what this program will do:__________________________________________________ 9.Build, download and execute the program
Observe the result and see if itis as expected. 10.   11.Increase the delay between digits
What do you observe?__________________________________________________ Decrease the delay between digits
What do you observe?__________________________________________________12.As can be seen, multiplexing technique here involves turning on only onedigit of display at a time, and after a short delay, move on to the nextdigit etc:Show ‘0’ on digit DIG0.DelayShow ‘1’ on digit DIG1.DelayShow ‘2’ on digit DIG2.DelayShow ‘3’ on digit DIG3.DelayRepeat aboveThe delay is to give time for the LED’s to light up and the number to beseen
Too long a delay will cause the numbers to flicker and too short andthe display will become blur, as the LED’s do not have time to turn onproperly and be seen.13.You may try to display today’s date as DDMM and show it to yourclassmates.Lab 3 – Interfacing to 7-segment displays and buzzer Page 7 of 16  14.Replace Four7Seg.c with Count7SegSw.c.Q-no.system MAPP  ____________________________________________________________________  Extra Exercise - Implementing a “queue number system” (Do this only if you still have time
Otherwise, skip to the next section to try out the “buzzer”.) 15.Study the code and describe what this program will do:__________________________________________________ Read the following explanation if you are stuck.The decimal numbers to display on the four 7-segments are stored in anarray of 4 unsigned charsunsigned char val[4];  // i.e
val [0], val [1], val [2], val [3]These are initialised to val [3] = 9; val [2] = 8; val [1] = 7; val [0] = 6; inthe main program
So, the initial display should be “9 8 7 6”.9876 are what you want to see
However, what the 7-segments want tobe told are the binary patterns 0b01101111 [9], 0b01111111 [8],0b00000111 [7], 0b01111101 [6].The function convert (in the seg7_utilities) produces the binary patternrequired to show a decimal number on a 7-segment
E.g
if decimal number(“digit”) = “0”, binary pattern (“leddata”) = 0b00111111.As you know by now, multiplexing technique is used to enable each of the4 digits in turn, so that the number of PIC pins required to display 4digits (including the decimal points) is fewer than 4 x 8.Here an unsigned char variable point is used to control which digit islighting up.16.17.18.19.20.21.22.It is initialised to 0b00000001 i.e
DIG0 will light up first.Lab 3 – Interfacing to 7-segment displays and buzzer Page 8 of 16 MAPP  ____________________________________________________________________  23.Putting all these ideas together, you get the following chunk of codes:point = 0b00000001;  // enable DIG0 firstfor (i = 0; i < 4; i++)  // loop from DIG0 to DIG3{  PORTB = point;    // enable one DIG   outchar = val [i];  // get one decimal number to display from the array    // convert to corresponding binary pattern for the 7-seg,   PORTD = convert (outchar);  // and send the binary pattern to the enabled DIG   point = point << 1; // shift left by 1 bit, to enable the next DIG, // so 0b00000001 becomes 0b00000010, then 0b00000100, // then 0b00001000   … // some delay } 24
Whenever the switch connected to RB5 is pressed, the 4-digit display isincremented by 1
This is done by the following lines of code and thefunction update:if (PORTBbits.RB5 == 0) // if switch is pressed{  press = 1; // this is explained below   val [0] = val [0] + 1;  // increment the lowest digit by 1   update ();  // update the other digits accordingly } 25.A micro-controller can work very fast
When a switch is pressed “onetime”, a micro-controller could have read it several times, and incrementthe display several times, as shown below:Display incremented by 10, although switch pressed “one time” switch PIC checking switch status Lab 3 – Interfacing to 7-segment displays and buzzer Page 9 of 16 MAPP  ____________________________________________________________________  26.To solve this problem, a variable press is used to control the flow of theprogram:…press = 0; // initially… in the “switch not pressed” statewhile (1){  … // display the decimal numbers   if (press == 0) // starting from the “switch not pressed” state     {       if (PORTBbits.RB5 == 0) // if switch pressed       {         press = 1; // change to the “switch pressed” state         … // increment the 4-digit number to display       }     } Display is only incremented the first time the switched is found to be pressed
Subsequently, only check for the release of the switch.   if (PORTBbits.RB5 == 1) // switch released     press = 0; // change to the “switch not pressed” state, ready for next round } 27.28.29.The best way to check whether you have understood this program is totry to explain it to a classmate.Once you have understood it, build, download and execute the program.Observe the result and see if it is as expected.Describe how you can use this in a Q-number system
What else do youneed?I still need _____________________________________________a.) display Your Q-number is 3208 c.) ticket printer + “counter” + user button b.) UP button Lab 3 – Interfacing to 7-segment displays and buzzer Page 10 of 16 MAPP  ____________________________________________________________________  Producing a tone on a buzzer Tone on buzzer  30.Replace Count7SegSw.c with Buzzone.c
31.Study the code and describe what this program will do:__________________________________________________ 32.Note that in Buzzone.c (under the function onetone), the variable is used:k.The “for” loop i.e
k determines the duration of the buzzing, while thedelay_us() determines the pitch of the buzzing.void onetone(void) //Function to generate one tone {     unsigned int k; for (k = 0; k < 100; k++) //Determines duration of tone delay_us(3000);  // useable values from 100  to 5000 PORTCbits.RC0 = !PORTCbits.RC0; //Invert logic level at RC0     {     } } 33.Build, download and execute the program
Observe the result and see if itis as expected.Lab 3 – Interfacing to 7-segment displays and buzzer Page 11 of 16 MAPP  ____________________________________________________________________  Different tone  34
Modify the program by adding another function named twotone with adifferent value in delay_us(value)
Include twotone in the main programand test out the sound effect, as follows:while (1){Onetone (); PORTD = 0b10101010; // pattern on LEDs delay_ms(500); Twotone (); PORTD = 0b01010101; // another pattern on LEDs delay_ms(500); while (1); // loop forever to stop music! } 35.Debug until the program can work.// Single7Seg.c // Program to test 1 7-segment display #include <xc.h> void main(void) { ADCON1 = 0x0F; TRISB=0b11110000; //RB3 to RB0 are connected DIG3 to DIG0 //RB5 is connected to a switch TRISD=0b00000000; //RD7 to RD0 are connected to segment LEDs while(1) { //repeat PORTB = 0b00000001; PORTD = 0b00111111;  //enable DIG0 //display 0 } } Lab 3 – Interfacing to 7-segment displays and buzzer Page 12 of 16 MAPP  ____________________________________________________________________  /* * File:   Four7seg.c* * Created on 13 January, 2016, 1:52 PM */ #include <xc.h> #include "delays.h" void main(void) { TRISB=0b11110000; //RB3 to RB0 are connected DIG3 to DIG0 //RB5 is connected to a switch TRISD=0b00000000; //RD7 to RD0 are connected to segment LEDs while(1) { //repeat PORTB = 0b00000001; PORTD = 0b00111111;  delay_ms(1000); PORTB = 0b00000010; PORTD = 0b00000110;  delay_ms(1000); PORTB = 0b00000100; PORTD = 0b01011011;  delay_ms(1000); PORTB = 0b00001000; PORTD = 0b01001111;  delay_ms(1000); //enable DIG0 //display 0 //LEDs on for a while //enable DIG1 //display 1 //LEDs on for a while //enable DIG2 //display 2 //LEDs on for a while //enable DIG3 //display 3 //LEDs on for a while } } Lab 3 – Interfacing to 7-segment displays and buzzer Page 13 of 16  MAPP ____________________________________________________________________ // Count7SegSw.c // Counting on 4 7-segment display by a switch on 7-seg Board #include <xc.h> #include "delays.h" #include "seg7.h" unsigned char point, outchar, press; void main(void) {     char i; TRISB = 0b11110000; //RB3 to RB0 are connected DIG3 to DIG0//RB5 is connected to a switch TRISD = 0b00000000; //RD7 to RD0 are connected to segment LEDs     val[3] = 9; //contents of DIG3     val[2] = 8; //contents of DIG2     val[1] = 7; //contents of DIG1     val[0] = 6; //contents of DIG0     press = 0;  while (1) //repeat     {  point = 0b00000001; //enable DIG0         for (i = 0; i < 4; i++)         { PORTB = point; //enable one DIG outchar = val[i]; //get one value for the DIG PORTD = convert(outchar); //convert to LED code point = point << 1; //point to the next DIG delay_ms(1);         }         { if (press == 0) //switch press first time if (PORTBbits.RB5 == 0) //if RB5sw is ON { press = 1; //switch being pressed val[0] = val[0] + 1; //increase DIG0 value update(); //adjust the rest of values        }         } if (PORTBbits.RB5 == 1) press = 0; //switch released     } } Lab 3 – Interfacing to 7-segment displays and buzzer Page 14 of 16 MAPP ____________________________________________________________________ // file : seg7.h unsigned char val[4]; // variable used extern void update(void) ; // update the above variable extern char convert(char outchar); // converts the outchar to 7 segment //display pattern /* * File:seg7_utilities.c* Created on 14 January, 2016, 7:59 PM */ #include <xc.h> extern unsigned char val[4]; char convert(char digit) {     char leddata; if(digit==0)leddata=0b00111111; if(digit==1)leddata=0b00000110; if(digit==2)leddata=0b01011011; if(digit==3)leddata=0b01001111; if(digit==4)leddata=0b01100110; if(digit==5)leddata=0b01101101; if(digit==6)leddata=0b01111101; if(digit==7)leddata=0b00000111; if(digit==8)leddata=0b01111111; if(digit==9)leddata=0b01101111;  return(leddata); } //Function to adjust DIG values void update(void) { if(val[0]>=10) { val[1]=val[1]+1; val[0]=0; } if(val[1]>=10) { val[2]=val[2]+1; val[1]=0; } if(val[2]>=10) { val[3]=val[3]+1; val[2]=0; } if(val[3]>=10) { val[3]=0; } } Lab 3 – Interfacing to 7-segment displays and buzzer Page 15 of 16 MAPP  ____________________________________________________________________   // BuzzOne.c // Program to activate buzzer with one tone // For project using USB interface with Bootloader #include <xc.h> #include "delays.h" void onetone(void) //Function to generate one tone {  unsigned int k; for (k = 0; k < 100; k++) //Determines duration of tone  delay_us(3000);  // useable values from 100  to 5000 PORTCbits.RC0 = !PORTCbits.RC0; //Invert logic level at RC0     {     } } void main(void) { TRISCbits.TRISC0 = 0; //-- Set RC0 as output TRISD = 0x00; //-- Set all pins on PortD as output     { onetone(); //sound ON then OFF PORTD = 0b10101010; //pattern on LEDs         delay_ms(500); onetone(); //sound ON then OFF PORTD = 0b01010101; //another pattern on LEDs         delay_ms(500); while (1); // loop forever to stop music!     } } Lab 3 – Interfacing to 7-segment displays and buzzer Page 16 of 16 MAPP                                                      ______________________________________________________________________  Lab 4 – Interfacing to keypad and LCD Objectives To learn to display an alphanumeric string on an LCD.To learn to read an input from a 4x4 keypad (using a 74922 keypad encoder).Introduction / Briefing LCD at Port D In this experiment, you will be displaying an alphanumeric string (numbers andcharacters) on an LCD connected to Port D
The LCD can display 2 lines of 16or 20 characters.Examine the connection below
Other than the power supply pins, you shouldbe able to locate the pins VEE, RS, R/W, E, DB7-0.Lab 4 – Interfacing to keypad and LCD Page 1 of 19 MAPP           ______________________________________________________________________   The connections & purpose of the pins are shown below:LCD pin VEE RS Remark / purpose Connection Variable resis  For contrast control
RD6 R/W E RD5 RD4 DB7-4 RD3-0 DB3-0 Not connected Register Select
Set RS = 0 to send “command” to LCD
Set RS = 1 to send “data” to LCD
Set R/W = 0 to write to LCD
Set R/W = 1 to read from LCD
Enable
Apply a falling edge (high to low transition) at E for LCD to latch on data / command at DB pins
Use only DB7-4 in 4-bit mode, in which a byte of data/command is written as 2 nibbles
Use DB7-0 in 8-bit mode, in which a full 8-bit byte is written in one go
An example of “command” is 0x01, which will clear the display
An example of “data” is 0x41 – the character “A” to display on the LCD. To make it easier for you to use the LCD, 4 functions have been written,based on the table above and the “commands for LCD module” on the nextpage
You don’t really have to understand the “fine prints” below or thetable on the next page.void lcd_write_cmd (signed char cmd) void lcd_write_data (char data) void lcd_strobe (void) void lcd_init (void)  A function for writing a command byte to the LCDin 4 bit mode. If you look at the code, you will notice that RS is set to 0,and the command byte sent out as two nibbles. A function for writing a data byte to the LCD in 4bit mode. If you look at the code, you will notice that RS is set to 1, andthe command byte sent out as two nibbles. A function for generating the strobe signal, i.e
a high to lowtransition at the Enable (E) pin. A function for initialising the LCD. The code configures Port D as an output port and set R/W to0, so that data/command can be written to the LCD. The command lcd_write_cmd(0x28) or 0b001010xx puts theLCD into the 4-bit, 2 lines, 5x7 dots mode. The command lcd_write_cmd(0x0E) or 0b00001110 turns thedisplay & cursor on. The command lcd_write_cmd(0x06) or 0b00000110 causesthe cursor position to be incremented after every char. The command lcd_write_cmd(0x01) clears the display andreturns the cursor to the home position.Lab 4 – Interfacing to keypad and LCD Page 2 of 19 MAPP              ______________________________________________________________ _______COMMANDS FOR LCD MODULE 1   0 1   1   0 0   1   0 Lab 4 – Interfacing to keypad and LCD Page 3 of 19 MAPP                 ______________________________________________________________________   There is no need to start from scratch when you need to use LCD
You canmodify an existing “main” function to suit your new application.In a typical “main” function (e.g
that of LCD2Lines.c below)o The LCD is first initialised using LCD_init().o Then, the cursor is move to the desired positionlcd_write_cmd(0x80) moves it to line 1 position 1 whilelcd_write_cmd(0xC0) moves it to line 2 position 1.o The command lcd_write_data (0x41) write the letter “A” to thecurrent cursor position etc.// LCD2Lines.c void main(void) {  lcd_init();  while(1)  { lcd_write_cmd(0x80);      lcd_write_data(0x41); ….. // Initialise LCD module // Move cursor to line 1 position 1 // write "A" to LCD Binary patterns for different characters Lab 4 – Interfacing to keypad and LCD Page 4 of 19 MAPP             ______________________________________________________________________ Q1: Fill in the blanks below to show how you can display “HELLO” on the first line of the LCD, and “WORLD” on the second line. // Hello World.c void main(void) {  _______________  while(1)  {  _______________  lcd_write_data(0x_____);  lcd_write_data(0x_____);  lcd_write_data(0x_____);  lcd_write_data(0x_____);  lcd_write_data(0x_____);  _______________  lcd_write_data(0x_____);  lcd_write_data(0x_____);  lcd_write_data(0x_____);  lcd_write_data(0x_____);  lcd_write_data(0x_____);  while(1);   } // while } // main // Initialise LCD module // Move cursor to line 1 position 1 // write "H" to LCD // write "E" to LCD // write "L" to LCD // write "L" to LCD // write "O" to LCD // Move cursor to line 2 position 1 // write "W" to LCD // write "O" to LCD // write "R" to LCD // write "L" to LCD // write "D" to LCD //stop here for now Q2:  What do you think is achieved by the code below? Your answer: _______________________________________________ unsigned char K, outchar; char Message [ ] = "Enter PIN number :  "; // Defining a 20 char string void main(void) {     lcd_init();     while(1)     {         lcd_write_cmd(0x80);          for (K = 0; K < 20; K++)         {    outchar = Message[ K ];    lcd_write_data(outchar);         } … // Initialise LCD module // Move cursor to line 1 position 1 // for 20 char LCD module // write character data to LCD Lab 4 – Interfacing to keypad and LCD Page 5 of 19 MAPP              ______________________________________________________________________ Q3:  What changes do you need to make to display “Welcome to SP“? Your answer: _______________________________________________ Keypad at Port B In the second part of this experiment, you will be reading from a 4x4 keypad(with encoder) connected to Port B (pins 0, 1, 2, 3 and 5).Examine the connection below
See how the 16 keys are labelled
The columnsare numbered X1, X2, X3, X4 (from left to right) while the rows arenumbered Y1, Y2, Y3, Y4 (from top to bottom)
So, the key 2 is X2, Y1 whilethe key B is X3, Y4.Q4:  Which key corresponds to X2, Y3? Your answer: _______________________________________________ These 8 signals (X’s and Y’s) from the keypad are connected to a keypadencoder 74C922 which has the truth table below
As a result of “encoding”, 8bits become 5 bits.Lab 4 – Interfacing to keypad and LCD Page 6 of 19 MAPP       ______________________________________________________________________ Keypad Encoder truth table X1Y1 D  0 C  0 B  0 A  0 D1 A X2Y1 0 0 0 1 1 X3Y1 0 0 1 0 1 X4Y1 0 0 1 1 1 X1Y2 0 1 0 0 1 X2Y2 0 1 0 1 1 X3Y2 0 1 1 0 1 Keys X1Y3 1 0 0 0 1 X4Y2 0 1 1 1 1 X2Y3 1 0 0 1 1 X3Y3 1 0 1 0 1 X4Y3 1 0 1 1 1 X1Y4 1 1 0 0 1 X2Y4 1 1 0 1 1 X3Y4 1 1 1 0 1 X4Y4 1 1 1 1 1 D (msb), C, B, A identify the key pressed
For instance, if key ‘2’ is pressed,X2, Y1 cause DCBA = 0001. [Note: This does not tell the key pressed is 2, asbinary 0001 is not exactly decimal 2
Further interpretation is needed – see Ccode below.]  The DA (data available) signal will be set to logic ‘1’, whenever akey is pressed.Q5:  What happen if key ‘6’ is pressed? Your answer:   key ‘6’ is X__ & Y__
So, DCBA = ______, DA = ______ The function to read & interpret the key is this:#define KEY_DA   PORTBbits.RB5  // 74922 DA output #define KEY_PORT   PORTB  // RB3 to RB0 has keypad data char getkey (void) {   char keycode;  const unsigned char lookup[] = "123F456E789DA0BC ";  while (KEY_DA==0);  // wait for key to be pressed keycode=KEY_PORT & 0x0F;  // read from encoder at portB,  // mask off upper 4 bits  while (KEY_DA==1);  // wait for key to be released return( lookup [keycode] ); // look up table to find   // key pressed } Lab 4 – Interfacing to keypad and LCD Page 7 of 19 MAPP        ______________________________________________________________________   The function waits for DA to become 1 i.e
a key pressed
Then it reads fromPort B and mask off the top 4 bits, i.e
only RB3 to RB0 (connected to thesignals D, C, B and A) are retained
After that, it waits for the key to bereleased
Finally, it returns the key pressed by looking up the look-up-table.0000 1111 lookup [] = "123F456E789DA0BC ";key 2  X2, Y1  DCBA = 0001  “2" (result) Likewise, if key B has been pressed, you get thislookup [] = "123F456E789DA0BC ";key B  X3, Y4  DCBA = 1110  “B" (result) hardware C code Q6:  Try key 8… lookup [] = "123F456E789DA0BC ";key 8  X__, Y__  DCBA = ____  “__" (result) hardware C code Lab 4 – Interfacing to keypad and LCD Page 8 of 19 MAPP           ______________________________________________________________________ Q7:  Assuming the hardware connections are unchanged, but the 4x4 keypad has been labelled differently, as follows: What changes to the look up table is necessary for correct interpretation? Your answer:  lookup [] = "1___4____7____*____ "; Q8.  You will come across the following code in the last part of the experiment
lcd_write_cmd(0xC0); // Move cursor to line 2 position 1 for ( i = 0; i < 20; i++) // for 20 number {  key=getkey(); // use “getkey” function to read/interpret key pressed    lcd_write_data(key); // display on LCD } Describe what happens when the code is executed: Your answer: __________________________________________ Lab 4 – Interfacing to keypad and LCD Page 9 of 19 MAPP             ______________________________________________________________________ Activites: Before you begin, ensure that the Micro-controller Board is connected to the LCD / Keypad Board
Displaying an alphanumeric string on LCD 1.2. 3
Launch the MPLABX IDE and create a new project called Lab4.Add the file LCD2Lines.c to the Lab4 project Source File folder.Make sure Copy is ticked before you click Select
If you have forgotten thesteps, you will need to refer to the previous lab sheet.Note that the program uses the functions lcd_init (), lcd_write_cmd (),lcd_write_data () from lcd_utilities.c and contains #include “lcd.h”
The fileslcd.h and lcd_utilities.c need to be added to the Project.Study the code (the main function) and describe what this program will do:__________________________________________________4.Build, download and execute the program
Observe the result and see if it isas expected. 5
Modify the code to show the following on the LCD
Build, download andexecute the program to verify your coding.JOHN 9123456 Reading inputs from keypad and displaying them on LCD  6
Replace LCD2Lines.c with LCDKeypad.c
The files keypad.h andkeypad_utilities.c (which contains the getkey () function) need to be added tothe Project
Likewise, the files delays.h and delays_utilities.c need to beadded.Display msg on LCD Changing the msg on LCD Keypad entries on LCD Lab 4 – Interfacing to keypad and LCD Page 10 of 19 MAPP            ______________________________________________________________________ 7.Study the code and describe what this program will do:__________________________________________________8.Build, download and execute the program
Observe the result and see if it isas expected.4-keyPIN no.on LCD 9
Modify the code to accept a 4-key PIN number (-- see Hint below)
Build,download and execute the program to verify your coding.Hint: unsigned char P1, P2, P3, P4;  // variables to store a copy of the PIN number  // entered
Put this BEFORE any executable code in main // put the following after the code to move cursor to line 2 position 1, // replacing the 2nd for loop key = getkey(); // get the first key P1 = key; // save first key in P1 lcd_write_data(key); // display on LCD key = getkey(); // get the second key P2 = key; // save second key in P2 lcd_write_data(key); // display on LCD … while(1); // add this to prevent program from restarting after 4th key Lab 4 – Interfacing to keypad and LCD Page 11 of 19 MAPP           ______________________________________________________________________ Hiding the  PIN number 10.  Further modify the code so that it will not display the actual PIN numberentered
Instead, * will be shown after each key.Enter PIN number: * * * _ Optional: After 4 keys have been entered, the program can show the message: “Processing……” Hint: You need to have a char array: Message2 [] = “ Processing…..” and a loop to display this message
11.Build, download and execute the program to verify your coding
Debug untilthe program can work.Password protected” access Password protected door  12.Replace LCDKeypad.c with LCDKeypadPwd.c
13.This program will accept a 4-key password (or “PIN number”)
If the correctpassword is entered, the LCD will display “OPEN”
Otherwise, the LCD willdisplay “WRONG”14
What do you think is the password?Your answer:  __________15.Build, download and execute the program
Observe the result and see if it isas expected.Lab 4 – Interfacing to keypad and LCD Page 12 of 19 MAPP              ______________________________________________________________________ // LCD2Lines.c // Program to test LCD. // The LCD display with two lines, 24 characters each. // There are three control lines (RD4:RD6) and four data lines(RD3:RD0). // RD6 - RS=0 Data represents Command, RS=1 Data represents Character // RD5 - RW=0 Writing into the LCD module // RD4 - E =1 Data is latched into LCD module during low to high transition#include <xc.h> #include "lcd.h"  // Include file is located in the project directory void main(void) { lcd_init(); while(1) { // Initialise LCD module lcd_write_cmd(0x80); lcd_write_data(0x41); lcd_write_data(0x42); lcd_write_data(0x43); lcd_write_cmd(0xC0); lcd_write_data(0x31); lcd_write_data(0x32); lcd_write_data(0x33); while(1); // Move cursor to line 1 position 1 // write "A" to LCD // write "B" to LCD // write "C" to LCD // Move cursor to line 2 position 1 // write "1" to LCD // write "2" to LCD // write "3" to LCD //stop here for now } }Lab 4 – Interfacing to keypad and LCD Page 13 of 19 MAPP          ______________________________________________________________________   // LCDKeypad.c // Program to test LCD and keypad. // For project using USB interface with Bootloader #include "lcd.h" #include <xc.h> #include "keypad.h" #include "delays.h" unsigned char key,outchar; char Message1 [ ] = "Enter PIN number :  ";   // Defining a 20 char string // ---- Main Program --------------------------------------------------------------- void main(void) { int i; lcd_init(); while(1) { // Initialise LCD module // Move cursor to line 1 position 1 //for 20 char LCD module lcd_write_cmd(0x80); for (i = 0; i < 20; i++) { } outchar = Message1[i]; lcd_write_data(outchar); // write character data to LCD lcd_write_cmd(0xC0); for (i = 0; i < 20; i++) { key=getkey(); lcd_write_data(key); } // Move cursor to line 2 position 1 //for 20 number // waits and get ascii key number when pressed //display on LCD delay_ms(1000);       lcd_write_cmd(0x01); // wait 1 second // 00000001 Clear Display instruction } }  // LCDKeypadPwd.c // Program to test LCD and keypad. // For project using USB interface with Bootloader #include <xc.h> #include "lcd.h" #include "delays.h" #include "keypad.h" unsigned char key, outchar; unsigned char p1, p2, p3, p4; char Message1 [ ] = "Enter PIN number :  "; // Defining a 20 char string void main(void) {  int i;  lcd_init(); // Initialise LCD module Lab 4 – Interfacing to keypad and LCD Page 14 of 19 MAPP                                ______________________________________________________________________  while (1) {                lcd_write_cmd(0x80); // Move cursor to line 1 osition 1 for (i = 0; i < 20; i++) { outchar = Message1[i];lcd_write_data(outchar); // write character data to LCD}  lcd_write_cmd(0xC0); // Move cursor to line 2 position 1 key = getkey(); // waits and get an ascii key number when  p1 = key; pressed lcd_write_data(key); //display on LCD key = getkey(); // waits and get an ascii key number when pressed  p2 = key; lcd_write_data(key); //display on LCD key = getkey(); // waits and get an ascii key number when pressed  p3 = key; lcd_write_data(key); //display on LCD key = getkey(); // waits and get an ascii key number when pressedp4 = key; lcd_write_data(key); //display on LCD  if (p1 == '4' && p2 == '5' && p3 == '5' && p4 == '0')  { lcd_write_data(0x20); lcd_write_data('O'); lcd_write_data('P'); lcd_write_data('E'); lcd_write_data('N'); lcd_write_data(0x20); lcd_write_data(0x20); lcd_write_data('W'); lcd_write_data('R'); lcd_write_data('O'); lcd_write_data('N'); lcd_write_data('G');  }   else   {         }     } } Lab 4 – Interfacing to keypad and LCD Page 15 of 19 LCD interface header fileSee lcd.c for more infoMAPP      ______________________________________________________________________ /*  file : lcd.h ***/ /* intialize the LCD - call before anything else */ extern void lcd_init(void); /* write a byte to the LCD in 4 bit mode */ extern void lcd_write_cmd(unsigned char cmd); //extern void lcd_write(unsigned char i); extern void lcd_write_data(char data); /* * File:   lcd utilities.c** Created on 13 January, 2016, 10:28 AM  */ //#include "LCD.H"  // Include file is located in the project directory #include <xc.h> #define _XTAL_FREQ 48000000 #define LCD_RS PORTDbits.RD6    //  Register Select on LCD #define LCD_EN PORTDbits.RD4    //  Enable on LCD controller #define LCD_WR PORTDbits.RD5    //  Write on LCD controller void lcd_strobe(void); //--- Function for writing a command byte to the LCD in 4 bit mode ------------- void lcd_write_cmd(unsigned char cmd) {     unsigned char temp2;     LCD_RS = 0;     __delay_ms(4);     temp2 = cmd;     temp2 = temp2 >> 4;     PORTD = temp2 & 0x0F;     __delay_ms(8);     lcd_strobe();     __delay_ms(8);     temp2 = cmd;     PORTD = temp2 & 0x0F;     __delay_ms(8);     lcd_strobe();     __delay_ms(8); // Select LCD for command mode // 40us delay for LCD to settle down // Output upper 4 bits, by shifting out lower 4 bits // Output to PORTD which is connected to LCD // 10ms - Delay at least 1 ms before strobing // 10ms - Delay at least 1 ms after strobing // Re-initialise temp2 // Mask out upper 4 bits // 10ms - Delay at least 1 ms before strobing // 10ms - Delay at least 1 ms before strobing } Lab 4 – Interfacing to keypad and LCD Page 16 of 19  MAPP        ______________________________________________________________________ //---- Function to write a character data to the LCD --------------------------- void lcd_write_data(char data) {   char temp1;     LCD_RS = 1;     __delay_ms(4);     temp1 = data;     temp1 = temp1 >> 4;     PORTD = temp1 & 0x0F;     __delay_ms(8);     lcd_strobe();     __delay_ms(8);     temp1 = data;     PORTD = temp1 & 0x0F;     __delay_ms(10);     lcd_strobe();     __delay_ms(10); // Select LCD for data mode // 40us delay for LCD to settle down //_-_ strobe data in //_-_ strobe data in } //-- Function to generate the strobe signal for command and character---------- void lcd_strobe(void) { // Generate the E pulse // E = 1 // 10ms delay for LCD_EN to settle // E = 0 // 10ms delay for LCD_EN to settle     LCD_EN = 1;     __delay_ms(8);     LCD_EN = 0;     __delay_ms(8); } Lab 4 – Interfacing to keypad and LCD Page 17 of 19 MAPP          ____________________________________________________________________ //---- Function to initialise LCD module ---------------------------------------- void lcd_init(void) {     int i;     TRISD = 0x00;     PORTD = 0x00;   LCD_EN = 0;     LCD_RS = 0;     LCD_WR = 0;     for(i=0;i<100;i++)     __delay_ms(10); // PORTD is connected to LCD data pin // Select LCD for command mode // Select LCD for write mode // Delay a total of 1 s for LCD module to // finish its own internal initialisation     /* The datasheets warn that LCD module may fail to initialise properly when        power is first applied
This is particularly likely if the Vdd  supply does not rise to its correct operating voltage quickly enough.        It is recommended that after power is applied, a command sequence of 3 bytes of 30h be sent to the module
This will ensure that the module is in 8-bit mode and is properly initialised
Following this, the LCD module */        can be switched to 4-bit mode
lcd_write_cmd(0x33);     lcd_write_cmd(0x32);     lcd_write_cmd(0x28);     lcd_write_cmd(0x0E);     lcd_write_cmd(0x06);     lcd_write_cmd(0x01);     __delay_ms(10); } // 001010xx – Function Set instruction // DL=0 :4-bit interface,N=1 :2 lines,F=0 :5x7 dots // 00001110 – Display On/Off Control instruction // D=1 :Display on,C=1 :Cursor on,B=0 :Cursor Blink on // 00000110 – Entry Mode Set instruction // I/D=1 :Increment Cursor position // S=0 : No display shift // 00000001 Clear Display instruction // 10 ms delay Lab 4 – Interfacing to keypad and LCD Page 18 of 19 MAPP                                   ______________________________________________________________________ // file : keypad.h extern char getkey(void); // waits for a keypress and returns the ascii code /* * File:   keypad utilities.c** Created on 13 January, 2016, 10:46 AM  */ #include <xc.h> #define KEY_DA PORTBbits.RB5   //  74922 DA output #define KEY_PORT PORTB // RB3 to RB0 has keypad data //----- Function to obtained wait for key press and returns its ASCII value char getkey(void){ char keycode;  const unsigned char lookup[] = "123F456E789DA0BC ";     while (KEY_DA==0);     keycode=KEY_PORT & 0x0F;     while (KEY_DA==1);     return(lookup[keycode]); } //wait for key to be pressed //read from encoder at portB,mask upper 4 bits //wait for key to be released //convert keycode to its ascii value for LCD Lab 4 – Interfacing to keypad and LCD Page 19 of 19 MAPP  ____________________________________________________________________  Lab 5 – Analogue to digital converter and interfacing high power devices Objectives To learn to use the ADC (Analogue to Digital Converter) in thePIC18F4550 microcontroller.To learn to turn some high power devices (e.g
motor, relay) on and off.Introduction / Briefing PIC18F4550’s ADC The PIC18F4550 microcontroller has a built-in ADC module capable ofconverting up to 13 analogue inputs to their corresponding 10-bit digitalrepresentations.analogue input 13 channels AN0 AN1 AN2 AN12 ADC 10-bit result1 0 1 0 1 1 1 1 00 The analogue input pins AN0 to AN12 could be connected to a variety ofsensors for monitoring the environment.For instance, a LDR (Light Dependent Resistor) circuit can be used tosense the ambient brightness
The result is an analogue voltage, whichcan be converted to a digital equivalent, and then used by the PIC tomake a decision – if it is too dark, switch on the lights
Other sensorsinclude sensors for temperature, water level, humidity, PH value etc.In this experiment, a variable resistor is used to give a variable voltageinput and the result of AD conversion will be shown on an L E D bar (- alow power output device)
Later, you will work on a fish tank “water levelmonitoring” application – If the water level is too high, turn on the motor(- a high power output device) to pump away the excess water
If thewater level is too low, turn on the alarm (- another high power outputdevice) to alert the owner.First, the registers associated with PIC18F4550’s ADC:Lab 5 – ADC and interfacing high power devices Page 1 of 10 MAPP ____________________________________________________________________  ADCON0 – This register controls the operation of the A/D module
Q1:  What binary pattern must be written to ADCON0 to select Channel 0 for conversion, and to power up the ADC module? (Don’t start the conversion yet.) Your answer: _______________________________________________ The C code required is ADCON0 = 0b 00 0000 0 1;Note that to start the conversion, the GO bit must be set to 1
Whenconversion is finished, the same bit (read as DONE) will be set to 0.Lab 5 – ADC and interfacing high power devices Page 2 of 10 MAPP ____________________________________________________________________  ADCON1 - This register configures the voltage references and the functions of the port pins
Q2:  What binary pattern must be written to ADCON1 to use VSS (0 Volt) and VDD (5 Volt) as reference voltages, and to make AN2 to AN0 analogue inputs (and the remaining inputs i.e
AN12 to AN3 digital)? Your answer: _______________________________________________ The C code required is ADCON1 = 0b 00 00 1100;Lab 5 – ADC and interfacing high power devices Page 3 of 10 MAPP  ____________________________________________________________________  ADCON2 - This register configures the A/D clock source, programmed acquisition time and justification
Q3:  What binary pattern must be written to ADCON2 to select left justified result (*), to set acquisition time of 4 TAD, and to select FOSC/64 as the clock source? Your answer: _______________________________________________ The C code required is ADCON2 = 0b 0 0 010 110;Note: Refer to lecture notes for details of acquisition time & clocksource selection.Lab 5 – ADC and interfacing high power devices Page 4 of 10 MAPP  ____________________________________________________________________  (*) Justification When an A/D conversion is completed, the 10-bit result is stored in theregisters ADRESH and ADRESL, either left-justified or right-justified,depending on the value of the ADFM bit, as shown below
Note that theother bits are filled with 0’s.ADFM = 1 10-bit result ADFM = 0 7  6  5  4  3  2  1  0  7  6  5  4  3  2  1  0 0  0  0  0  0  0 7  6  5  4  3  2  1  0  7  6  5  4  3  2  1  0 0  0  0  0  0  0 ADRESH ADRESL ADRESH ADRESL 10-bit, right-justified10- bit, left- Example 1 – Showing the result of conversion on an L E D bar In the circuit below, the variable resistor is used to produce an analogueinput – by turning the knob on the variable resistor, the AN0 voltage canbe varied
This voltage can then be AD converted into a 10-bit digitalequivalent
The most significant 8 bits can then be displayed on the L E Dbar.Vdd A/D converter 5 V Variable  resistor Analogue input AN0 Digital output at Port D 8 Lab 5 – ADC and interfacing high power devices Page 5 of 10 MAPP ____________________________________________________________________  The complete C code is as follows:void main(void) {     TRISD = 0x00;    // Set PORTD to be output PORTD = 0x00;   // Initialise PORTD LEDs to zeros     /* Configuring the ADC */     ADCON0 = 0b00000001;     ADCON1 = 0b00001100; ADCON2 = 0b00 010 110; // bit5-2  0000 - select channel 0 for conversion // bit1  A/D conversion status bit // // // bit0  Set to 1 to power up A/D 1- GO to starts the conversion0 - DONE when A/D is completed// bit5 // bit4 // bit3-0  1100 - AN2 to AN0 Analog, the rest Digital 0 -reference is VSS 0 - reference is VDD // bit7  A/D Result Format: //     0 - Left justified //     1 - Right justified // bit5-3  010 - acquisition time = 4 TAD // bit2-0  110 - conversion clock = Fosc / 64     for( ; ; )     {         ADCON0bits.GO = 1; // This is bit2 of ADCON0, START CONVERSION NOW         while(ADCON0bits.GO == 1);   // Waiting for DONE         PORTD = ADRESH; …. // continue… / Displaying only the upper 8-bits of the A/D result Using transistor as a switch – motor & relay Low power devices such as LED’s can be driven directly by themicrocontroller pins
To control a higher power device such as motor /relay, a transistor can be used as a switch as shown below.For instance, in the motor circuit on the right below, the microcontrollerpin RC2 is used to turn the motor on and off.When RC2 = 1, the transistor (2N2222) is switched on, allowing a currentto flow through & turn the motor.When the transistor is switched off, the diode (1N4001) allows currentto continue flowing through the motor, avoiding damage to the motorcircuit, especially the transistor.Lab 5 – ADC and interfacing high power devices Page 6 of 10 MAPP  ____________________________________________________________________  In the relay circuit on the left above, the microcontroller pin RC1 is usedto energise the relay.When RC1 = 1, the transistor is switched on, allowing a current to flowthrough the coil & the relay is energised
An energised relay closes thecontact between points 1 and 2, as well as 3 and 4.Since 3 & 4 are now in contact, a current can flow through and turn onthe LED
Likewise, points 1 & 2 can be used for connecting an alarm orother high power device.Note that the high power device connected to points 1 & 2 could bepowered by a different power source
The relay can thus provide powerisolation.Lab 5 – ADC and interfacing high power devices Page 7 of 10 MAPP  ____________________________________________________________________  Example 2 – Turning on the pump/motor when water level is high, turning on the alarm when water level is low HIGH LOW With the above discussion, it will not be difficult for you to build a fishtank “water level monitoring” application
If the water level is too high,the pump motor will be turned on to drain away the excess water
If thewater level is too low, an alarm will be activated to alert the owner.Activites: Before you begin, ensure that the Micro-controller Board is connected to the General IO Board
Showing the result of AD conversion on an L E D bar 1.2.Launch the MPLABX IDE and create a new project called Lab5.Add the file ADC.c to the Lab5 project Source File folder.Make sure Copy is ticked before you click Select
If you have forgottenthe steps, you will need to refer to the previous lab sheet.3.Study the code and describe what this program will do:__________________________________________________4.Build, download and execute the program.Lab 5 – ADC and interfacing high power devices Page 8 of 10 MAPP  ____________________________________________________________________  5.Turn the variable resistor R1 (on the General IO Board) to each of the 5positions marked below.Observe & record the 10-bit digital result on the LED bar (also on theGeneral IO Board) – actually only the 8 most significant bits are shown onthe LED bar, so the 2 least significant bits can be taken as 0 0.The equivalent input voltage can be “back computed” using the formula:Voltage = ( N-bit digital result x 5 V ) / 2N (N = 10 for 10-bit converter) [Note: some said it should be divided by 2N – 1
It really depends on the coding scheme used
See Wikipedia for a discussion.] _ _ _ _ _ _ _ _ 0 0 ≡ ____ V _ _ _ _ _ _ _ _ 0 0 ≡ ____ V _ _ _ _ _ _ _ _ 0 0 ≡ ____ V _ _ _ _ _ _ _ _ 0 0 ≡ ____ V _ _ _ _ _ _ _ _ 0 0 ≡ ____ V 6.Are the results as expected i.e
the 10-bit digital result as well as theequivalent input voltage should increase as the knob is turned clockwise?Your answer: ____________________________________________Fish tank “water level monitoring” 7.Modify the code above so that if the water level is above a certain level(for instance when the 10-bit digital result exceeds 0xD0), the pumpmotor at RC2 is turned on to pump away the excess water
On the otherhand, if the water level is below a certain level (for instance 0x10), therelay at RC1 is turned on to sound an alarm to alert the owner.Note that you need to define LOW in your code
The if-else statementmust also be expanded to control the relay.8.Build, download and execute the program to verify your coding
Debuguntil the program can work.Lab 5 – ADC and interfacing high power devices Page 9 of 10 MAPP ____________________________________________________________________ // ADC.c // Program to use ADC to read variable resistor input and display on LEDs  #include <xc.h> void main(void) {     #define HIGH 0xD0 // HIGH water level indicator     TRISD = 0x00;  PORTD = 0x00; // Set PORTD to be output // Initialise PORTD LEDs to zeros     TRISCbits.TRISC1 = 0;  // RC1 as output pin     PORTCbits.RC1    = 0;   // RC1 is connected to Relay     TRISCbits.TRISC2 = 0;  // RC2 as output pin     PORTCbits.RC2    = 0;   // RC2 is connected to Motor     /* Initialise analog to digital conversion setting */     ADCON0 = 0b00000001;     ADCON1 = 0b00001100; ADCON2 = 0b00 010 110; // bit5-2  0000 select channel 0 conversion // bit1  A/D conversion status bit // // // bit0  Set to 1 to power up A/D 1- GO to starts the conversion0 - DONE when A/D is completed// bit5 // bit4 // bit3-0  AN2 to AN0 Analog, the rest Digital reference is VSS reference is VDD // bit7  A/D Result Format:     0 - Left justified // //     1 - Right justified // bit5-3  010 acquisition time = 4 TAD // bit2-0  110 conversion clock = Fosc / 64     for( ; ; )     {         ADCON0bits.GO = 1; // This is bit2 of ADCON0, START CONVERSION NOW         while(ADCON0bits.GO == 1);   // Waiting for DONE         PORTD = ADRESH; // Displaying only the upper 8-bits of the A/D result         if(ADRESH > HIGH)         {     PORTCbits.RC2 = 1;   } else    PORTCbits.RC2   = 0;         {         }     } } // Turn on Motor  // Turn off Motor Lab 5 – ADC and interfacing high power devices Page 10 of 10 MAPP ____________________________________________________________________  Lab 6 – Programmable timer and PWM (Pulse Width Modulation) Objectives To learn to introduce a time delay using Timer0 in the PIC18F4550microcontroller.To learn to use PWM for the speed control of a DC motor.Introduction / Briefing PIC18F4550’s Timer0 for delay The PIC18F4550 microcontroller has four internal timers
We will firstuse Timer0 to introduce a time delay and then use Timer2 to control thespeed of a DC motor using Pulse Width Modulation (PWM).In the first part of the experiment, the LED bar at Port D will be blinked(turned ON and OFF repeatedly) at 1 second interval
Let’s figure outhow the 1 second interval or delay can be created with the help ofTimer0.Example 1: Assume that a 16-bit counter/timer is clocked by a 1 MHzclock signal
How long does it take to count from 0000 to FFFF and thenroll over? [Roll over means changing from the maximum count of FFFF to0000.]Counting from 0000 to FFFF and then rolling over is equivalent to 65,536counts
Since each count takes 1us, this is equal to 65,536 us = 65.536 ms.Example 2: Now try this: what count should the counter starts with, sothat exactly 50 ms has elapsed when roll over occurs?Since each count takes 1us, 50 ms is equal to 50 ms / 1us = 50,000 counts.So the count should start from 65,536 – 50,000 = 15,536.Lab 6 – Programmable timer & PWM 1 of 14 MAPP  ____________________________________________________________________  This is shown by the diagram below: 1 MHz 16 bit timer 0x???? Step 1: Clock period = 1 / (1 MHz)  = 1 us Rolling over 0xFFFE 0xFFFF 0x0000  In the case of PIC18F4550’s Timer 0: Step 3: Start counting from 65,536 – 50,000 = 15,536 so that when roll over occurs, 50 ms has elapsed
Step 2: A delay of 50 ms = A count of 50 ms / 1 us = 50,000 counts  The timer/counter clock frequency = Fosc / 4 = 48 MHz / 4 = 12 MHz. An interrupt flag TMR0IF will be set to 1 whenever the timeroverflows from FFFF to 0000. A pre-scaler can be used to slow down the clock
For instance, a pre-scale value of 256 slows down the clock by 256 times, effectively, thetimer/counter is clocked by a 12MHz / 256 clock signal.Example 3: Assume that the PIC18F4550’s  16-bit Timer0 is clocked by a48 MHz / 4 clock signal and a pre-scale value of 256 is used
What countshould the timer starts with, so that exactly 1 sec has elapsed when rollover occurs?Effective clock frequency for Timer0 = 48 MHz / 4 / 256 = 46875 HzEach count = 1 / (46875 Hz) = 21.333 us.A delay of 1 sec = a count of 1 sec / 21.333 us = 46,875 counts.So the Timer0 should start from 65536 – 46875 = 18661 or hex 48E5 –the conversion from decimal to hex can be done using the PC’s calculator(Programs -> Accessories -> Calculator).Lab 6 – Programmable timer & PWM 2 of 14 MAPP  ____________________________________________________________________  This is shown by the diagram below:48 MHz / 4  Pre-scaler ÷ 256 16 bit Timer0 0x???? Step 1: Clock period = 1 / (48 MHz / 4 / 256 )  = 21.333 us Rolling over TMR0IF = 1 0xFFFE 0xFFFF 0x0000 Step 3: Start counting from 65,536 – 46,875 = 18,661 or hex 48E5, so that when roll over occurs, 1 sec has elapsed
Step 2: A delay of 1 sec = A count of 1 sec / 21.333 us = 46,875 counts How do you set a pre-scaler of 256 & a starting count value of hex 48E5?How do you know that Timer0 overflow has occurred i.e
TMR0IF hasbecome 1? To answer these questions, we must take a look at Timer0registers.The following diagram shows how the various Timer0 registers affect itsoperations
You can come back to examine this diagram later, after theindividual registers have been described.How the various registers affect Timer0 operations Fosc/4  T0CK1 pin 0 1 T0SE Programmable Pre-scaler 1:1 to 1:256 3 T0CS T0PS2:T0PS0 T0CON 1 0 TMR0H:TMR0L 8/16-bit Timer/Counter registers turn on overflow TMR0ON PSA 8/16-bit T08BIT TMR0IF [bit 2 of INTCON] Lab 6 – Programmable timer & PWM 3 of 14 MAPP  ____________________________________________________________________  TMR0H & TMR0L (Timer0 High & Low Registers) – These two 8-bit registers together form a 16-bit timer/counter
TMR0H TMR0L D15  D14  D13  D12  D11  D10  D9  D8  D7  D6  D5  D4  D3  D2  D1  D0 To set a starting count value of hex 48E5, hex 48 should be written toTMR0H first, and then hex E5 written to TMR0L.Q1:  Give the C code to set a starting count value of hex 48E5: Your answer: TMR0H = _______; _____________ ; INTCON (Interrupt Control Register) bit 2 =TMR0IF (Timer0 Interrupt “overflow” Flag) – This bit is set to 1 whenever the Timer0 overflows i.e
count from FFFF to 0000
INTCON TMR0IF Q2:  Give the C code to wait for Timer0 overflow to occur: Your answer: while (_____bits._____ == 0); T0CON (Timer0 Control Register) – This register controls the Timer0 operation (as described below)
It is used to turn the timer ON/OFF and to set the pre-scaler value
TMR0ON  T08BIT T0CS T0SE PSA T0PS2 T0PS1 T0PS0 TMR0ON D7 Timer0 ON and OFF control bit 1 = Enable (start) Timer0 0 = Stop Timer0 T08BIT D6 Timer0 8-bit / 16-bit selector bit 1 = Timer0 is configured as an 8-bit timer/counter 0 = Timer0 is configured as a 16-bit timer/counter T0CS D5 Timer0 clock source select bit 1 = External clock from RA4/T0CK1 pin 0 = Internal clock (Fosc/4 from XTAL oscillator) Lab 6 – Programmable timer & PWM 4 of 14 MAPP ____________________________________________________________________  T0SE D4 Timer0 source edge select bit 1 = Increment on H-to-L transition on T0CK1 pin 0 = Increment on L-to-H transition on T0CK1 pin PSA D3 Timer0 pre-scaler assignment bit 1 = Timer0 clock input bypasses pre-scaler 0 = Timer0 clock input comes from pre-scaler output T0PS2:T0PS0  D2 D1 D0 0   0   0 = 1:2 0   0   1 = 1:4  0   1   0 = 1:8  0   1   1 = 1:16 1   0   0 = 1:32 1   0   1 = 1:64 1   1   0 = 1:128 1   1   1 = 1:256 Timer0 pre-scaler selector Pre-scale value (Fosc/4/2) Pre-scale value (Fosc/4/4) Pre-scale value (Fosc/4/8) Pre-scale value (Fosc/4/16) Pre-scale value (Fosc/4/32) Pre-scale value (Fosc/4/64) Pre-scale value (Fosc/4/128) Pre-scale value (Fosc/4/256) Q3:  What binary pattern must be written to T0CON to use Timer0 as a 16-bit timer using internal clock (Fosc/4) and a pre-scale value of 256? The timer is NOT to be turned on at this point
Your answer: T0CON (Timer0 Control Register) TMR0ON  T08BIT T0CS T0SE PSA T0PS2 T0PS1 T0PS0 The C code required is T0CON = 0b 0 0 0 0 0 111;Lab 6 – Programmable timer & PWM 5 of 14 MAPP  ____________________________________________________________________  Putting the pieces together, the C code to introduce a time delay of 1second can be written as follows:    T0CON=0b00000111; // Off Timer0, 16-bits mode, Fosc/4, prescaler of 256     TMR0H=0X48;     TMR0L=0XE5;     INTCONbits.TMR0IF=0;     T0CONbits.TMR0ON=1; // Starting count value // Clear flag first // Turn on Timer 0     while(INTCONbits.TMR0IF==0);     T0CONbits.TMR0ON=0;  // Wait for time’s up i.e
TMR0IF==1 // Turn off Timer 0 to stop counting Description:  1
First, Timer0 is configured but turned OFF.  2
Then,the starting count value is written toTMR0H, followed by TMR0L.  3.Next, the flag is cleared and Timer0 turned ON.  4
After that, the whileloop is used to wait for 1 second to elapse i.e
for the TMR0IF interruptflag to be set.  5
Finally, Timer0 is turned OFF.With this, you should be able to figure out the TimerDelay.c used in thefirst part of the experiment to blink the LED bar at Port D at 1 secondinterval.PIC18F4550’s Timer2 for PWM In the second part of the experiment, PWM (Pulse Width Modulation) willbe used to control the speed of the DC motor connected to RC2
We willnow describe what PWM is and how it can be created with the help ofTimer2.PWM Rectangular wave with certain period & duty cycle Lab 6 – Programmable timer & PWM 6 of 14 MAPP  ____________________________________________________________________  PWM PWM (Pulse Width Modulation) is a method used to control the speed ofa DC motor.When 5V is applied to a small DC motor, it turns at a certain speed.A 75% duty cycle rectangular wave is high for 75% of the time (and lowfor 25% of the time)
When this is applied, the motor slows down –effectively, it is getting 5V x 75% or 3.75V d.c.75 % wave 75 % of period is HIGH period When a 50% duty cycle wave is applied, the motor slows down further, asit is effectively getting 2.5V d.c.Pulse Width Modulation = varying the duty cycle of the rectangular wave(i.e
varying the pulse width) to control the motor speed.In creating a rectangular wave or pulse train, we must know both 1
theperiod and 2
the duty cycle.How do we create a rectangular wave of a certain period and duty cycle inPIC18F4550? Let’s try a 5 kHz, 25% duty cycle wave.PIC18F4550 has a CCP (Capture Compare) module which comes with PWMcapability
The PWM output comes out at RC2.For PWM, the CCP module uses two Timer2 registers to specify theperiod:PWM period = ( PR2 + 1 ) x 4 x N x Tosc where PR2 is Timer2’s 8-bit “Period register” N = Timer2’s pre-scale value of 1, 4 or 16, as set in T2CON (Timer2 Control) register (* see box on next page) Tosc = 1 / Fosc, where Fosc = 48 MHz Lab 6 – Programmable timer & PWM 7 of 14 MAPP  ____________________________________________________________________  Some Timer2 registers PR2 (Period Register) D7  D6  D5  D4  D3  D2  D1  D0 T2CON (Timer2 Control Register) D7 TOUTPS3  TOUTPS2  TOUTPS1  TOUTPS0  TMR2ON  T2CKPS1  T2CKPS0 D7 – not used TOUTPS3:TOUTPS0 D6 D5 D4 D3 TMR2ON D2 T2CKPS1:T2CKPS0 D1 D0 Timer2 output post-scaler selector 0 0 0 0 = 1:1 Post-scale value 0 0 0 1 = 1:2 Post-scale value 0 0 1 0   = 1:3 Post-scale value … 1 1 1 1 = 1:16 Post-scale value Timer2 ON and OFF control bit 1 = Enable (start) Timer2 0 = Stop Timer2 Timer2 clock pre-scaler selector 0 0 = 1:1 Pre-scale value 0 1 = 1:4 Pre-scale value 1 X = 1:16 Pre-scale value Q4.  What is the PR2 value to generate a 5 kHz wave, assuming a pre-scaler of 16? Your answer: _______________ SolutionFrequency = 5 k    Period = 1 / 5k = 0.2 mTosc = 1 / 48M Pre-scaler, N = 16Substituting into the formula,PWM period = ( PR2 + 1 ) x 4 x N x Tosc 1 / 5k = ( PR2 + 1 ) x 4 x 16 x (1 / 48M) => PR2 = 149 Lab 6 – Programmable timer & PWM 8 of 14 MAPP  ____________________________________________________________________  The “High Time” (or “On Time”) is specified using another register calledCCPR1L, as follows:High Time = 25% of Period 25% x 149 = 37.25 = 37 (ignoring the decimal portion) => CCPR1L = 37 The bottom 4 bits of the CCP1 Control Register (CCP1CON) should be setto 1100 for PWM operation.CCP1CON (CCP1 Control Register) D7 D6 DC1B1 DC1B0 CCP1M3 CCP1M2 CCP1M1 CCP1M0 1 1 0 0 for PWM mode Other combinations for Capture / Compare modes not studied in this module Let’s put everything together to program the PIC18F4550 to generate a5 kHz, 25% wave.The complete program (in outline form) is given below:TRISC=0x00;   // RC2 is connect to motor and should be made an output T2CON=0b0 0000 1 11;  // Timer2 is On, Prescaler is 16 CCP1CON=0b00 00 1100; // Turn on PWM PR2 = 149; CCPR1L = 37;   // Load PWM period of 0.2 ms or 5 kHz // Load PWM on time ( i.e
25% x 149 ) With this, you should be able to figure out the TimerPWM.c used in thesecond part of the experiment to control DC motor speed using PWM.Lab 6 – Programmable timer & PWM 9 of 14 MAPP ____________________________________________________________________  Activites: Before you begin, ensure that the Micro-controller Board is connected to the General IO Board
Blinking an LED bar at 1 second interval, using a delay created using Timer0 1.2.Launch the MPLABX IDE and create a new project called Lab6.Add the file TimerDelay.c to the Lab6 project Source File folder.Make sure Copy is ticked before you click Select
If you have forgottenthe steps, you will need to refer to the previous lab sheet.3.Study the code and describe what this program will do:  4.5.__________________________________________________Note that the main function configures the Timer0 but does not turn itON
The Timer0 is only turned on in the Delay1sec function.Build, download and execute the program
Observe the result and see if itis as expected.Blink LED bar at 1 sec intervals
Lab 6 – Programmable timer & PWM 10 of 14 Change start count value to change delay
Change pre-scaler to change delay.  6
MAPP  ____________________________________________________________________  Modify the code so that the delay is 0.5 second (instead of 1 second).Keep pre-scaler of 256.Hint:  Since Fosc remains at 48 MHz and pre-scaler remains at 256, theeffective clock frequency of Timer0 remains unchanged at 48 MHz /4 / 256 = 46875 Hz.Each count = 1 / (46875 Hz) = 21.333 us, the same as before. A delay of 0.5 sec = a count of 0.5 sec / 21.333 us = 23438 counts. So the Timer0 should start from 65536–23438 = 42098 or hex A472.7.Build, download and execute the program to verify your coding
The LEDbar now blinks at a faster rate. 8
Without changing the start count value in 6 above, modify the code touse a pre-scaler of 64 (instead of 256). [Hint: T0CON = 0b00000___;]What effect do you think this will have on the rate of blinking?Your answer: The LED bar will blink at a ______ (faster/slower) rate.9.Build, download and execute the program to verify your answer above.Lab 6 – Programmable timer & PWM 11 of 14 MAPP  ____________________________________________________________________  Controlling DC motor speed, using PWM created using Timer2 10.Replace TimerDelay.c withTimerPWM.c. 11
The TimerPWM.c code is to produce a 5 kHz, 25% duty cycle wave at RC2using PWM.PWM 5kHz 25% duty cycle PWM 5kHz 25%, 50% or 75% duty cycle depending on dip switches 12.Build, download and execute the program
Use the oscilloscope connectedto RC2 (/ DC motor) to see if the period & duty cycle are correct
Recordyour observations below:On time = _____ RC2 Period = _____ Frequency = _____ Duty cycle = _____ 13.14.Note that PR2 = 149, CCPR1L = 37 in this case.Note also the speed of the DC motor at 25%. 15
The value of CCPR1L to get a 5 kHz, 50% duty cycle wave is simply50% x 149 = 74 Likewise, to get a 5 kHz, 75% duty cycle wave, CCPR1L = 75% x 149 = 112 16.Modify the code so that the duty cycle produced depends on the settingsof the (active low) dip switches (on the General IO Board) connected toRA4 and RA3, as follows:RA4 RA3 Duty Cycle Closed i.e. == 0 don’t care 75 % Open i.e. == 1 Closed i.e. == 0 50 % Open i.e. == 1 Open i.e. == 1 25 % (high speed) (medium speed) (low speed) 17.Build, download and execute the program to verify your coding
Debuguntil the program can work.Lab 6 – Programmable timer & PWM 12 of 14 MAPP ____________________________________________________________________ // TimerDelay.c /* TimerDelay.c Program containing a 1 sec delay function * Use Timer0* Frequency of OSC = 48 MHz, Prescaler = 256* TMR0H:TMR0L contain the starting count value* Monitor TMR0IF flag
When TMR0IF = 1, one sec is over*/#include <xc.h> void Delay1sec(void); void Delay1sec(void) {     TMR0H=0X48;     TMR0L=0XE5; // Function to provide 1 sec delay using Timer0 // Starting count value     INTCONbits.TMR0IF=0;      T0CONbits.TMR0ON=1;  // Clear flag first // Turn on Timer 0     while(INTCONbits.TMR0IF==0);   T0CONbits.TMR0ON=0;  } // Wait for time is up when TMR0IF=1 // Turn off Timer 0 to stop counting void main(void) {     TRISD=0x00;     T0CON=0b00000111;      while(1)     {         PORTD=0x00;         Delay1sec();          PORTD=0xFF;         Delay1sec();     } } // PortD connected to 8 LEDs // Off Timer0, 16-bits mode, prescaler to 256 // Repeatedly // Off all LEDs // On all LEDs Lab 6 – Programmable timer & PWM 13 of 14  MAPP  ____________________________________________________________________ // TimerPWM.c /* TimerPWM.c Program to generate PWM at RC2 * Use Timer2* Frequency of OSC = 48 MHz, Prescaler = 16* PR2 register set the frequency of waveform* CCPR1L with CP1CONbits.DC1B0, CCP1CONbits.DC1B1 set the On-Time* Use Timer0 for the one second delay function*/#include <xc.h>void Delay1sec(void); void Delay1sec(void) {     TMR0H=0X48;     TMR0L=0XE5; // Function to provide 1 sec delay using Timer0 // Starting count value     INTCONbits.TMR0IF=0;      T0CONbits.TMR0ON=1;  // Clear flag first // Turn on Timer 0     while(INTCONbits.TMR0IF==0);  // Wait for time is up when TMR0IF=1     T0CONbits.TMR0ON=0;  } // Turn off Timer 0 to stop counting void main(void) { // Do not remove these as well=============     ADCON1 = 0x0F;     CMCON = 0x07; // ======================================== // Your MAIN program Starts here: =========     TRISC=0x00;     TRISD=0x00;     T0CON=0b00000111;   // PortC RC2 connects to motor // PortD connected to 8 LEDs // Off Timer0, 16-bits mode, prescaler to 256     T2CON=0b00000111; // Timer2 is On, Prescaler is 16     CCP1CON=0b00001100;     PR2 = 149; // Turn on PWM on CCP1, output at RC2 // Load period of PWM 0.2msec for 5KHz     while(1)     {         CCPR1L = 37;     } } // Repeatedly      // Duty cycle 25%, 149 x 25% = 37 Lab 6 – Programmable timer & PWM 14 of 14 MAPP         ______________________________________________________________________  Lab 7 – Interrupt programming Objectives To learn to use PIC18F4550 microcontroller’s INT0 external hardwareinterrupt & Timer0 interrupt.To learn to the sequence of code execution in an interrupt event.Introduction / Briefing What is interrupt? A microcontroller can use the interrupt method to respond to an event.In this method, when a peripheral (e.g
an I/O pin or a timer) needs somethingto be done, it notifies the micro-controller, which stops whatever it is doingand “serves” the peripheral
After that, the micro-controller goes back tocontinue what it was doing.As an analogy, you could be reading newspaper
When there is a buzz tone onyour hand phone, you are “interrupted” – you stop reading and reply an SMS.After that, you continue reading your newspaper where you left off.The program associated with the interrupt is aptly called the interruptservice routine or ISR.In this experiment, you will learn the basics of interrupt, focusing on INT0external hardware interrupt and Timer0 interrupt, (though there are manyother interrupt sources in the PIC).Lab 7 – Interrupt programming 1 of 14 MAPP         ______________________________________________________________________ Sequence of code execution   The diagram below shows the sequence of code execution in an interruptevent:main function {  interrupt_set_up;  while(1)  { statement_a; statement_b; ….
statement_n;  } } 1 2 3 6 ISR { code to handle interrupt clear flag return to main program 4 5 } (*) After interrupt has been set up, the while loop in the main function isexecuted over and over again (1, 2…).Let’s say an interrupt event occurs when statement_a is being executed (3).The microcontroller will complete the execution of this statement
Then it willgo to a specific location (*) called the “interrupt vector” to look for the ISR(interrupt service routine).In the ISR, the codes to handle the interrupt will get executed (4).After that, the microcontroller will return to the main function to continuewith statement_b (5), and the while loop will get executed over and over again(6…).In the lab, a “boot-loader” is used in the PIC18F4550
This program downloads a user program from a PC via the USB port
The “boot-loader” changes the high and low-priority interrupt-vectors to 0x001008 and 0x001018, respectively
Lab 7 – Interrupt programming 2 of 14              MAPP          ______________________________________________________________________ INT0 external hardware interrupt  The PIC18F4550 has 3 external hardware interrupts: INT0, INT1 and INT2which use pins RB0, RB1 and RB2 respectively
We will discuss INT0 (andINT1 and INT2 are similar in terms of operation).The INT0 interrupt responds to a change of voltage i.e
a transition at RB0.To enable the INT0 interrupt, set both the GIE (Global Interrupt Enable) andthe INT0IE (INT0 Interrupt Enable) bits in the INTCON register.INTCON (Interrupt Control Register) GIE 1 INT0IE 1 INT0IF Q1
Give the C-code to enable the INT0 interrupt
INTCONbits.______ = ______; ________________________; The INTEDG0 bit of the INTCON2 register is used to specify whetherinterrupt is to occur on a falling (i.e
a high to low transition) or a rising (i.e
alow to high transition) edge at RB0:INTCON2 (Interrupt Control Register 2) INTEDG0 0 INTEDG0 = 0: INT0 interrupt on falling edge at RB0 INTEDGO = 1: INT0 interrupt on rising edge at RB0 (power-on reset default) Q2.  Give the C-code to select falling edge triggering
INTCON2bits.______ = ______; Note that falling edge triggering has been chosen because on themicrocontroller board, the push button switch at RB0 has been connected as“active low”.When interrupt has been enabled and there is a falling edge at RB0, the flagINT0IF (external hardware INTerrupt 0 Interrupt Flag) in the INTCONregister will be set
To clear this flag, so that future interrupt can be noticed,use the code   INTCONbits.INT0IF = 0;Lab 7 – Interrupt programming 3 of 14 MAPP          ______________________________________________________________________               With these, you should be able to understand the code in Int_INT0_b.c.Interrupt priority (D.I.Y.) By default, all interrupts are “high priority”.It is also possible to make some interrupts “high priority” and others “lowpriority”
This is done by setting the IPEN (Interrupt Priority ENable) bit inthe RCON register.When interrupt priority is enabled, we must classify each interrupt source ashigh priority or low priority
This is done by putting 0 (for low priority) or 1(for high priority) in the IP (interrupt priority) bit of each interrupt source.The IP bits for the different interrupt sources are spread across severalregisters – INTCON, INTCON2, INTCON3, IPR1 and IPR2
We will not gointo the details of all these.A higher priority interrupt can interrupt a low priority interrupt but NOTvice-versa.Lab 7 – Interrupt programming 4 of 14 MAPP          ______________________________________________________________________ Timer0 interrupt In the last experiment, you used Timer0 to introduce a delay of 1 second
TheC code was:    T0CON=0b00000111; // Off Timer0, 16-bits mode, Fosc/4, prescaler to 256     TMR0H=0X48;     TMR0L=0XE5; // Starting count value     INTCONbits.TMR0IF=0;     T0CONbits.TMR0ON=1; // Clear flag first // Turn on Timer 0     while(INTCONbits.TMR0IF==0);     T0CONbits.TMR0ON=0;  // Wait for time is up when TMR0IF=1 // Turn off Timer 0 to stop counting First, Timer0 is configured but turned OFF.  Then, the starting count value is written to TMR0H, followed by TMR0L.  Next, the flag is cleared and Timer0 turned ON.  After that, the while loop is used to wait for 1 second to elapse i.e
for the TMR0IF interrupt flag to be set.  Finally, Timer0 is turned OFF
Instead of “polling” for the timer overflow (from FFFF to 0000) usingwhile (INTCONbits.TMR0IF == 0); the “interrupt” method can be used
The advantages of the interrupt method over the polling method are discussed in the lecture
The Timer0 interrupt responds to Timer0 overflow.To enable the Timer0 interrupt, set both the GIE (Global Interrupt Enable)and the Timer0IE (Timer0 Interrupt Enable) bits in the INTCON register.INTCON (Interrupt Control Register) GIE 1 TMR0IE 1 TMR0IF Q3.  Give the C-code to enable the Timer0 interrupt
INTCONbits.______ = ______; ________________________; When interrupt has been enabled and there is a Timer0 overflow, the flagTimer0IF (TiMeR0 overflow Interrupt Flag) in the INTCON register will beset
To clear this flag, so that future interrupt can be noticed, use the codeINTCONbits.TMR0IF = 0;Lab 7 – Interrupt programming 5 of 14 MAPP                                               ______________________________________________________________________ With these, you should be able to understand the Timer0 Interrupt codeoutlined as follows. (This is similar to, but not exactly the same as, theInt_TMR0.c used in the experiment.)main function INTCONbits.GIEH =1; Global Interrupt Enable INTCONbits.TMR0IE = 1; Timer0 Interrupt Enable Enable interrupt T0CON = 0b00000111; Stop Timer0, 16-bit, Fosc/4, pre-scaler 256 TMR0H = 0x48; TMR0L = 0xE5; Starting count value for a 1 second delay INTCONbits.TMR0IF = 0;  Clear Flag T0CONbits.TMR0ON = 1; Turn on Timer0 Configure Timer0 for 1 sec delay while (1) {   … } ISR if (INTCONbits.TMR0IF) {     TMR0H = 0x48; TMR0L = 0xE5;     …
PIC free to do other things in while loop e.g
use slide switch to turn motor on/off Check that it is really Timer0 overflow causing the interrupt Reload Timer0 with starting count value - for the next round Respond to interrupt and reload for next interrupt.     INTCONbits.TMR0IF = 0; Clear flag, to get ready for the next interrupt } Lab 7 – Interrupt programming 6 of 14 MAPP          ______________________________________________________________________ Activites:   Before you begin, ensure that the Micro-controller Board is connected to the General IO Board
External hardware interrupt 1.This part of the experiment uses the LED bar connected to Port D and themotor connected to RC2
Both are found on the General IO Board.2.This part of the experiment also uses the push button connected to RB0
Thisis found on the Micro-controller Board.3.4.Polling an active low switch at RB0  5
Launch the MPLABX IDE and create a new project called Lab7.Add the file Int_INT0_a.c to the Lab7 project Source File folder.Make sure Copy is ticked before you click Select
If you have forgotten thesteps, you will need to refer to the previous lab sheet.Study the code
In the main program the function “LED_RD7_RD0” is firstcalled to light up the LED’s in the bar, one by one, from left to right.Lab 7 – Interrupt programming 7 of 14 MAPP                      ______________________________________________________________________ Then the switch at RB0 is checked
The first time it is pressed (i.e
becomes 0), the motor at RC2 is turned on
The next time it is pressed, the motor is turned off
No interrupt is used and the RB0 switch is responded to only after the LED bar sequence has completed
6.Build, download and execute the program
Press the switch at RB0 to controlthe motor on/off
Does the motor respond promptly to the switch?Your answer: ________________________________________Using interrupt for the active low switch at RB0 7. 8
Replace Int_INT0_a.c with Int_INT0_b.c .Study the code
This time, INT0 interrupt is used.Can you find the main function and the ISR?In the main function, can you find the codes that enable the interrupt, selectfalling edge triggering and clear the flag?In the while loop in the main function, the function  “LED_RD7_RD0” is calledto light up the LED’s in the bar, one by one, from left to right.Pressing the switch at RB0 causes an interrupt event to occur
The interruptservice routine for the “active low” button at RB0 is called ISR_PortB0_low.9.10.The ISR first checks that the INT0IF is set.The first time the switch at RB0 is pressed (i.e
becomes 0), the motor at RC2is turned on
The next time it is pressed, the motor is turned off.The ISR clears the flag at the end so that the next interrupt event can berecognised and responded to.{You may have noticed that there is no line of code “checking” if RB0 has beenpressed in the form of  “if (PORTBbits.RB0 == 0)”
This is because interrupt isused, instead of polling.}11.Build, download and execute the program
Press the switch at RB0 to controlthe motor on/off
Does the motor respond promptly to the switch?Your answer: ________________________________________Lab 7 – Interrupt programming 8 of 14 Using interrupt for Timer0 overflow MAPP             ______________________________________________________________________ Timer0 interrupt 12.This part of the experiment also uses the on/off switch connected to RA3.This is found on the General IO Board.13.  14.Replace Int_INT0_b.c with Int_TMR0.c.Study the code
This time, Timer0 interrupt is used.Can you find the main function and the ISR?In the main function, can you find the codes that enable the interrupt,configure the Timer0, clear the flag and turn on the Timer0?15.16.In the while loop in the main function, the switch at RA3 is used to turn themotor on/off.Timer0 overflow causes an interrupt event to occur
The interrupt serviceroutine for the Timer0 overflow is called ISR_Timer0_Int.The ISR first checks if TMR0IF is set.If so, the timer is reloaded with the starting count value (to get ready forthe next round)
A variable j is incremented and then displayed on the LEDbar connected Port D.At the end, the TMR0IF flag is cleared, so that the next interrupt event canbe recognised and responded to.17.Build, download and execute the program
Turn the switch at RA3 on/off tosee if the motor can be turned on/off.Your answer: ________________________________________18.Next, look at the LED bar and record your observation below:Your answer: ________________________________________Lab 7 – Interrupt programming 9 of 14 MAPP       _____________________________________________________________________ 19.There are two processes – main and ISR - in the program but the micro-controller can only run one process at a time
Do you feel that the motor isresponding well to the switching at RA3 when the LED’s are counting?Beeping every second 20.  Your answer: ________________________________________Finally, modify the program so that the buzzer will beep every second.Your answer: ________________________________________21.Build, download and execute the program to verify your coding
Debug untilthe program can work.// Int_INT0_a.c Polling based program#include <xc.h> #include "delays.h" unsigned char j; unsigned char press; void LED_RD7_RD0(void)// The function to shift a set-bit from left to right { j = 0x80; while(j!=0x01) {   PORTD = j;   delay_ms(250);    // Calling a delay function from delays.h   j = j>>1;  } PORTD = j; //  Initialise  j  with  B1000 0000  //  ie  the  leftmost  bit (or MSB) // Check that the bit has not been shifted // to the right-most bit (LSB) ie B00000001 // Display j at PORTD // Making use of LOGICAL-RIGHT-SHIFT bit-wise // operator to shift data to the right // Display j at PORTD // Stop at B00000001 } void main(void) { // Main Function ADCON1 = 0x0F; CMCON = 0x07; TRISBbits.TRISB0 = 1; TRISCbits.TRISC2 = 0; TRISD = 0x00;  PORTD = 0x00;  press = 0; while(1) { // RB0 is the push button switch for INT0 // RC2 connects to a DC motor // PortD connects to a bar LEDs // LEDs all off // Not pressing yet // Main Process LED_RD7_RD0();  // Move Port D LEDs from bit7 to bit0 // polling the switch at RB0 if (PORTBbits.RB0 == 0) {       press++; // To track first or second time pressing RB0 switch Lab 7 – Interrupt programming 10 of 14 MAPP                                               ______________________________________________________________________       if (press == 1)       {          PORTCbits.RC2 = 1;       }       else       if (press == 2)       {          PORTCbits.RC2 = 0;          press = 0;       } } } } // First press // Turn On Motor // Second press // Else turn Off Motor // Reset the pressing counter // Int_INT0_b.c // Int_INT0_b.c Interrupt based program // ISR activated by INT0 from an active low switch from RB0 #include <xc.h> #include"delays.h" unsigned char i, j; unsigned char press, a, b; void interrupt ISR_PortB0_low(void) {  if (INTCONbits.INT0IF)// External Interrupt Flag Bit = 1 when interrupt occurs   { // Interrupt Service Routine for INT0 // To track first or second time pressing RB0 switch press++; if (press == 1) {   PORTCbits.RC2 = 1; } else if (press == 2) {   PORTCbits.RC2 = 0;   press = 0; } // First press // Turn On Motor // Second press // Else turn Off Motor // Reset the pressing counter         INTCONbits.INT0IF = 0;    } } //Clearing the flag at the end of the ISR void LED_RD7_RD0(void)// The function to shift a set-bit from the MSB to LSB { j = 0x80; while(j!=0x01) {   PORTD = j;  delay_ms(250);    // Calling a delay function from delays.h   j = j>>1;  } PORTD = j; // Initialise j with B1000 0000// ie the leftmost bit (or MSB) // Check that the bit has not been shifted // to the right-most bit (LSB) ie B00000001 // Display j at PORTD // Making use of LOGICAL-RIGHT-SHIFT bit-wise // operator to shift data to the right // Display j at PORTD // Stop at B00000001 } Lab 7 – Interrupt programming 11 of 14                MAPP        ______________________________________________________________________ void main(void) { // Main Function ADCON1 = 0x0F; CMCON = 0x07; TRISBbits.TRISB0 = 1; // RB0 is the push button switch for INT0 TRISCbits.TRISC2  =  0;  //  RC2  connects  to  a  DC  motor TRISD = 0x00;PORTD = 0x00;  press = 0; j = 0; RCONbits.IPEN =1;  // Bit7 Interrupt Priority Enable Bit // PortD connects to a bar LEDs // LEDs all off // Not pressing yet // 1 Enable priority levels on interrupts // 0 Disable priority levels on interrupts INTCONbits.GIEH =1; // Bit7 Global Interrupt Enable bit // When IPEN = 1 // 1 Enable all high priority interrupts // 0 Disable all high priority interrupts INTCON2bits.INTEDG0 = 0;// Bit4 External Interrupt2 Edge Select Bit // 1 Interrupt on rising edge // 0 Interrupt on falling edge INTCONbits.INT0IE = 1;  // Bit4 INT0 External Interrupt Enable bit // 1 Enable the INT0 external interrupt // 0 Disable the INT0 external interrupt INTCONbits.INT0IF = 0;  // Clearing the flag while(1) { } // Main Process LED_RD7_RD0();  // Move Port D LEDs from bit7 to bit0 } Lab 7 – Interrupt programming 12 of 14 MAPP                    ______________________________________________________________________               // Int_TMR0.c /* Int_TMR0.c Timer Interrupt based program * ISR activated by Timer0 interrupt when it over-flow* Set up a Timer0 interrupt-driven program to count up the LEDs at PORTD at* 1 sec interval * * Timer0 is configured for 16 bit Timer Mode operation. * The TMR0 interrupt is generated when the TMRO register* overflows from FFFFh to 0000h.* This overflow sets the TMR0IF bit.* The TMR0IF bit must be cleared in software by the Timer0 module* ISR before re-enabling this interrupt. * * Timer0 starting value is set by writing to TMR0H and TMR0L. * For 1 sec, the starting value is 0x48E5* Main Process - configure external interrupt and use RA3 switch to control^ motor at RC2 */ #include <xc.h> unsigned char j; void interrupt ISR_Timer0_Int()  // Timer0 Interrupt Service Routine (ISR) {   if (INTCONbits.TMR0IF) // TMR0IF:- Timer0 Overflow Interrupt Flag Bit // 1 = TMR0 reg has overflowed // 0 = TMR0 reg has not overflowed     {         TMR0H = 0x48; // Timer0 start value = 0x48E5 for 1 second         TMR0L = 0xE5; j++; // Increase count by 1 PORTD = j; // Show count value at Port D Leds INTCONbits.TMR0IF = 0; // Reset TMR0IF to "0" since the end of // the interrupt function has been reached     } } void main(void) { // Main Function ADCON1 = 0x0F; CMCON = 0x07; TRISAbits.TRISA3 = 1; TRISCbits.TRISC2 = 0; TRISD = 0x00;  PORTD = 0x00;  j = 0; RCONbits.IPEN =1; INTCONbits.GIEH =1; T0CON = 0b00000111;    // RA3 is the On/Off switch // RC2 connects to a DC motor // PortD connects to a bar LEDs // LEDs all off // Start count from 0 // Bit7 Interrupt Priority Enable Bit // 1 Enable priority levels on interrupts // 0 Disable priority levels on interrupts // Bit7 Global Interrupt Enable bit // When IPEN = 1 // 1 Enable all high priority interrupts // 0 Disable all high priority interrupts // bit7:0 Stop Timer0 // bit6:0 Timer0 as 16 bit timer // bit5:0 Clock source is internal // bit4:0 Increment on lo to hi transition on TOCKI Lab 7 – Interrupt programming 13 of 14 MAPP                                ______________________________________________________________________                INTCON2 = 0b10000100; TMR0H = 0x48;  TMR0L = 0xE5;T0CONbits.TMR0ON = 1; INTCONbits.TMR0IE = 1; INTCONbits.TMR0IF = 0;  // bit3:0 Prescaler output of Timer0  // bit2-bit0:111 1:256 prescaler // bit7 :PORTB Pull-Up Enable bit  1 All PORTB pull-ups are disabled // // bit2 :TMR0 Overflow Int Priority Bit //   1 High Priority // Initialising TMR0H // Initialising TMR0L for 1 second interrupt // Turn on timer // bit5 TMR0 Overflow Int Enable bit //0 Disable the TMR0 overflow int// bit2 TMR0 Overflow Int Flag bit // 0 TMR0 register did not overflow while (1) // Main Process     {         if (PORTAbits.RA3 == 0)  // If RA3 switch is ON PORTCbits.RC2 = 1; // Turn On Motor         else PORTCbits.RC2 = 0; // Else turn Off Motor     } } Lab 7 – Interrupt programming 14 of 14 CDEF5RΩ0746RΩ0747RΩ0748RΩ0740DR1D1DR2D2DR3DV5CCV3Sb0DRb1DRb2DRb0BRb1BRb2BRBSU1HΩk0131R11R9R0BR4S1BR5S2BR6S01RΩ07421RΩ07441RΩ074tuO rewoP9H1 2 3V9PV5PltceeS rewoP1J12341 2 3V5V5UV5CCV3DR2DRtooB2SΩk013R4RΩ074V5CCV0554F81CPI1UFn001RLCM7BR6BR5BR3BR2BR1BR0BR7DR6DR5DR4DR7CR6CR04938373635343330392827262527BR6BR5BR4BR3BR2BR1BR0BR7DR6DR5DR4DR7CR6CR4232+D-D11Vdd132VddRLCM0AR1AR2AR3AR4AR5AR0ER1ER2ER1CSO2CSO0CR1CR2CRbsuV22123DR2DRVss1Vss0DR1DR3112123456789013141516171819102V5PV52UTC5087MLV9PV9GERVEGATLOVENLIFu0226CNOMMOCFu0225CA1 2 3 4 5 68HaRLCM2Ja7BRa6BRCCVV5a0ERa1ERa2ER981 2 37H7ETROPBDCIrewoP4DV5CCVCCVV5a0DRa4DRa1DRa5DRa2DRa6DRa3DRa7DR21345678901CCVV5a0CRa1CRa2CRa6CRaV5Pa7CR21345678901DTROPCTROPCCVV5a0BRa1BRa5BRa2BRa3BRV5CCV213456789014CBTROPATROPCCVV5a0ARa4ARa1ARa5ARa2ARa3AR213456789016H5H654324H103H2RΩ0740AR1AR2AR3AR4AR5AR0ER1ER2ERV5CCVΩk011R1SteseR0DR1DRFn0743C0CR1CR2CRFp221CzHM022CFp22E1XF2H NI  V9CDABCD9876543210ABCDEFGV5V5P876V5V5PB1UV5V5P5432102UrotoMM3D1004N12222N23Q21RΩ0742CRyaleR1UDEL1DΩ07411RA1U2Q2222N201RΩ0741CR2D1004N1I2_PS8X1  Ω0740DR1DR2DR3DR4DR5DR6DR7DRCCVV50DR4DR1DR5DR2DR6DR3DR7DR213 4 567 8 901CCVV54DR5DR6DR7DR3DR2DR1DR0DR213 4 567 8 901.3 ,2 ,1 ,0DR  era  7 ,5 ,3 ,1nPi.7 ,6 ,5 ,4DR  era  8 ,6 ,4 ,2nPiDtroPDtroP41R4D1suB5H9HAV5CCVΩ0748R1PrezzuB212222N21Q9RΩk2.20CR1SΩk016RV5CCV4R2RV5CCVΩ0743R5R7R3AR4AR5ARaA1UaB1U126H7H8H213 4 567 8 9213 4 567 8 90101BtroPBtroPCCVV5a0ARa4ARa1ARa5ARa2ARa3AR213 4 567 8 901CCVV5a0CRa1CRa2CRV5P213 4 567 8 9013H4H2H122AR1H121AR1RK531RΩ0740ARAtroPCtroP.5 ,4AR  era  4 ,2nPi.3 ,2 ,1 ,0AR  era  7 ,5 ,3 ,1nPi.2 ,1 ,0CR  era 5 ,3 ,1nPi876543210BCDEFGABCDEFGDEL stnemges-neves edona nommoC0GDI1D1GDI2D2GDI3D3GDI4D81716151413121110O1O2O3O4O5O6O7OV5CCVCCV91U0I1I2I3I18924I5IDNG106I7I12345678CCVV50BR1BR2BR3BR2suB2BR3BR0BR1BRa5BR213 4 567 8 9011HBtroP8765432105pd18kk35pd18kk35pd18kk35pd18kk3.3 ,2 ,1 ,0BR  era  7 ,5 ,3 ,1nPigfedcbagfedcbagfedcbagfedcba109124671091246710912467109124671RΩk012R5BR1SV5CCV3RΩ0745BRI1_PD8X2  Ω07481716151413121110O1O2O3O4O5O6O7OV5CCV10CCV2U0I1I2I3I30824I5IDNG96I7I12345678.7 ,6 ,5BR  era  8 ,6 ,4nPi1suB0DR1DR2DR3DR4DR5DR6DR7DR0DR4DR1DR5DR2DR6DR3DR7DRCCVV5213 4 567 8 9012HDtroP.3 ,2 ,1 ,0DR  era  7 ,5 ,3 ,1nPi.7 ,6 ,5 ,4DR  era  8 ,6 ,4 ,2nPi876543210ABCDEFGABCDEFGV5CCV1RK53121SdapyeK1,4YX,1,1Y4Y3Y2Y1X4X3X2X1876543217181AKDB7DB6DB5DB4DB3DB2DB1DB0ER/WRSVEE5VGND16151413121110987654321V5CCV3D2 RD1 RD0 RDR4D5 RD6 RDR11018712341X2X3X4X1Y2Y3Y4YV5CCVCCV18DNG91U229C47ABCDADCSOMBKEO716151412156310BR1BR2BR3BR5BRFn0011C2CFn0012H4H213 4 567 8 901213 4 567 8 901DtroPDtroP.3 ,2 ,1 ,0DR  era  7 ,5 ,3 ,1nPi.7 ,6 ,5 ,4DR  era  8 ,6 ,4 ,2nPi.3 ,2 ,1 ,0BR  era  7 ,5 ,3 ,1nPi.7 ,6 ,5BR  era  8 ,6 ,4nPi1H3H213 4 567 8 901213 4 567 8 901BtroPBtroP1004N11D12V5CCV2UDCL876543210ABCDEFG876543210MAPP Microcontroller Applications C-D-I-O Project Specifications1
C-D-I-O Project All students taking the MAPP module are required to complete a C (conceive) – D (design)– I (implement) – O (operate) project, as specified in this document.ConceiveDesignImplement&Operate2
Project Teams At the beginning of the semester, the students in each class will be grouped into teams of3 (min) or 4 (max)
The lecturer taking the class can decide on how the grouping is done.Imightaswellgotosleep…Thereisn’tworkformetodo.Howarewegoingtofinishtheproject?Weonlyhavetwopairsofhands.CDIOProjectSpecificationPage1MAPP3
Basic Requirement The project must use a microcontroller
Time Available & Module Assessments The project is to be done during the scheduled practical sessions (32 hours for MAPP, more than 4 weeks for ET0884) and contribute to 45% of the module assessment. The Schedule /Assessments in the Appendix shows the amount of time available for project, as well as the various assessments:C/DPresentation15%MST+BreakIShow&Tell30%“C/D”:1hr/weekx6weeksforET1010Term2“I”:2hrs/weekx2weeks+4hrs/weekx4weeks,forET1010CDIOProjectSpecificationPage2MAPP5
Conceive / Design (15% of module)  Each project team will propose an interesting, useful (in solving a real problem) andoriginal project idea
The project should also be feasible (i.e
doable by the studentswithin the given time & cost constraints) and cost-effective. The lecturer taking the class may set a “project theme” e.g. “microcontroller applicationsthat help the elderly”. The theme can also be based on the course of study e.g. “Clean Energy applications forstudents taking DEEE”, “Aerospace applications for students taking DASE” etc.CDIOProjectSpecificationPage3MAPP 6.”Design Thinking” Tools for C/D Various tools can be used in the Conceive stage:Journalist (“Interview”) – Imagine you are a newspaper reporter
Interview the target users to find out what they need.A-E-I-O-U (“Observation”) – Observe the target users and take note of the activities,environment, interactions, objects and users. Other tools can be used in the Design stage:Brainstorming – Come up with as many ideas as possible, based on your interviews /observation
Draw simple sketches to capture the ideas.Matrix for Generation – Sort the ideas into 4 quadrants
Focus on high impact, high feasibility ideas
CDIOProjectSpecificationPage4MAPP ConceiveDesignImplement&OperateTheC&Dstepsmap(roughly)totheEmpathy&Ideationstepsinatypical“DesignThinking”flowEmpathyIdeationPrototypeSimplified“DesignThinking”flow7
Block Diagram / Circuit Diagram / Flowchart After a project idea is selected, students will draw block diagram & circuit diagrams (forthe hardware design) & flowchart (for the software design) and to plan an implementationschedule .BrightnessSensorMotionDetectorMicrocontrollerBlockDiagramRelaytoOn/OffLightsCDIOProjectSpecificationPage5 FlowchartOFFlightsWeekWeekWeekWeek12141618MAPPDelayBright?nHuman?yONlightsynGetboards/componentsAssemblecircuitsImplementationPlanMakeconnectorsWriteprogramIntegrate/Test/DebugDemotoLecturerDesignContest(forET1010only)If you find it impossible to complete the project within the limited time given, you will need to scale down your project scope
CDIOProjectSpecificationPage6MAPP8
Presenting the Project Idea  At the end of the “C/D” stages, students will make a 10-15 minute presentation of theirwork.In the presentation, describe the research/analysis of user needs done, describe how theapplication works, outline its key features, show the block diagram/circuit diagrams,flowchart, implementation plan etc
Use sketches, photos, video clips, models todemonstrate the project idea where appropriate.9.“C/D” Assessment CriteriaHastheteamdonegoodresearch&analysistounderstanduserneeds?__/25Hastheteamcomeupwithacreativeidea/solutiontotheuser’sproblem?__/25Hastheteamshownthattheprojectisfeasiblewiththeblockdiagram,circuitdiagrams,flow‐chart&implementationplan?__/25Isthepresentationlively&engaging?__/25Althoughgroupmarkscanbeawarded,individualstudentscanscorehigher/lower,dependingonhis/hercontribution.CDIOProjectSpecificationPage7MAPP10
Implement (30% of module) In the second term, students implement their project ideas and then do a “show & tell”(i.e
a demo). The steps are outlined below:Getcomponents/boardsFabricateIOcircuits/connectorsProgrammemicrocontrollerIntegratehardware&softwareTest/debugprojectShow&tell“DesignContest”(forET1010only)CDIOProjectSpecificationPage8MAPP11
Project resources  The PIC18F4550 Microcontroller Board and the Keypad/LCD Board can be signed out fromthe lab
Likewise, the Interface Board (which allows other IO circuits to tap power fromthe Microcontroller Board) can be signed out from the lab. Students have to fabricate other IO circuits on strip boards, with components from theMAPP Lab
Write-ups on many IO devices (IR, LDR, Motion Sensor, Tilt Switch, DC Motor,Servo Motor Solenoid, Relay, Distance Measurement, Temperature Sensor, MoistureSensor, Real-Time-Clock, Voice Recording/Playback) are in the Blackboard. Students have to provide their own notebook (with software installed), soldering tools &multi-meters etc. Students are also free to use other suitable I/O devices not available from the lab.However, they have to source & pay for these themselves. Students should take good care of items on loan, as these must be returned at the end ofthe semester
Students will have to replace any lost/damaged items.CDIOProjectSpecificationPage9MAPP12
Demonstrating the Project  At the end of the “I” stage, students will do a 10-15 minute show & tell of their work.In the show & tell, outline the objective of the project – what is it supposed to do? Do ademo run, briefly described the technical difficulties involved.13. “I” Assessment CriteriaDidtheteamputineffortinimplementation?__/35Istheprojectworkingi.e.asuccess?__/35Istheshow&telllively&engaging?Canstudentsanswerquestionsasked?__/30Althoughgroupmarkscanbeawarded,individualstudentcanscorehigher / lower,dependingonhis / hercontribution.Selected groups can be nominated to enter a “Design Contest” (at the end of Term 2)
Bonus marks will be given to ALL participants
Certificates + Prizes will be given to the teams that come up with great idea, can do and can “sell”.        –- for ET1010 only CDIOProjectSpecificationPage10MAPPThisistoshowtoamountoftimeavailablefortheCDIOproject.PleaserefertoBlackboardfortheactualscheduleforthissemester.Singapore Poly  Appendix -CDIO Schedule / Assessments – MAPP DTL / TutorialPractical / Lab C-D-I-O Project & Design ThinkingAssessment DTL  / Tutorial 1 hr DTL + 1 hr Tutorial 2 hour Tutorial C1 – Introduction to micro-controller C2 – Microchip’s PIC18F4550 – an overview C3 – PIC18F4550’s I/O ports & device interfacing Practical / Project 3rd hour 1st hour 2nd hour Part I Exp 1: Intro to PIC18F4550 Board, MPLAB-IDE, C-compiler, USB downloader [installation of software tools on students’ notebooks ] Exp 2: Interfacing to switches + LEDs Exp 3: Interfacing to 7-segment display + buzzer C3 cont
Exp 4: Interfacing to keypad + LCD 4th hour Part II Empathy/Ideation,form team (“Conceive/Design”)     [part 1:select area of interest] Empathy/Ideation: observe (“Conceive/Design”)     [part 2: prepare for interview] Empathy/Ideation (“Conceive/Design”)    [part 3: brainstorm] Empathy/Ideation, (“Conceive/Design”)    [part 4: draft design & plan] Work on Conceive/Design presentation slides, Fill in 1st half of SDL form Improve Conceive/Designpresentation slidesFill in 1st half of SDL form Wk ET1010 ET0884 1 2 3 4 5 6 7 8-1112 14 15 16 17 Revision 18 Make up QuizC4 – PIC18F4550’s analogue to digital converter C5 – A brief “MPLAB-C18 Compiler” user’s guide Presenting the project idea conceived (Conceive/Design,CA3 -- 15%)Make up or revision C6 – PIC18F4550’s programmable timer / counter Exp 5: ADC (Analogue to Digital Converter) & interfacing to high power devices Make up or revision Lab Test (LAB 1 -- 15%) Presenting the project idea conceived (Conceive / Design, CA3 -- 15%) MST(for ET1010) / Class Test 1(for ET0884) ( 20% ) / VACATION Exp 6: Programmable timer & PWM (Pulse width modulation) Students request for components from Lab.  sign out other resources/PCBs etc
13 C6 cont
Exp 7: Interrupt programming Students start implementation of project (fabrication of I/O circuits on strip board, interfacing MCT board to I/O circuits
PIC programming, troubleshooting etc) C7 – PIC18F4550’s interrupt C7 cont
Students continue implementation of project Students continue implementation of project C8 – PIC18F4550’s serial port (a brief intro) Students continue implementation of project
Students fill in the 2nd half of SDL formStudents continue implementation of project,Student Submit SDL form to lecturer
Assessment of completed project.  Short-listed projects will participate in the DesignContest (with bonus marks) -- for ET1010 Assessment of the rest of the projects. (Implement, CA4 -- 30%)CA1 (GP) and Design Contest (Wed 2—5pm), for ET1010 only Class Test 2, for ET0884 onlyCDIOProjectSpecificationPage11Name: ________________________ Adm No: __________ Class: D____/ 2_____ 1st Half:       My Learning (Challenges and Strategies / Resources to Be Used):  Challenges: • •  Strategies/ Resources to be used to overcome the above challenges: • • Feedback Received From ( your lecturer and peers ) : • • Student Signature:_____________________    Date: _____________   ( By the week before MST ) 2nd Half: Follow-up Actions Done: (Key Challenges and Strategies/ Resources Used):  Key Challenge(s): •   Key Strategies / Resources used helps overcome the above challenge(s) most: • Evidence / Result: Student Signature:_____________________ Submission Date: _____________ ET1010 MAPP Reflection Form for CA1     (By the week of project interview)    Page 1 of 1             Engineering @ SP The School of Electrical & Electronic Engineering at Singapore Polytechnic offers the following full-time courses
Diploma in Aerospace Electronics (DASE) The Diploma in Aerospace Electronics course aims to provide students with a broad-based engineering curriculum to effectively support a wide spectrum of aircraft maintenance repair and overhaul work in the aerospace industry and also to prepare them for further studies with advanced standing in local and overseas universities
Diploma in Computer Engineering (DCPE) This diploma aims to train technologists who can design, develop, setup and maintain computer systems; and develop software solutions
Students can choose to specialise in two areas of Computer Engineering & Infocomm Technology, which  include  Computer  Applications,  Smart  City  Technologies  (IoT,  Data  Analytics),  Cyber  Security,  and  Cloud Computing
Diploma in Electrical & Electronic Engineering (DEEE) This diploma offers a full range of modules in the electrical and electronic engineering spectrum
Students can choose one of the six available specialisations (Biomedical, Communication, Microelectronics, Power, Rapid Transit Technology and Robotics & Control) for their final year.  4
Diploma in Energy Systems & Management (DESM)* The Diploma in Energy Systems & Management course aims to equip students with the knowledge and expertise in three specialisations: clean energy, power engineering and energy management, so as to design clean and energy efficient systems that will contribute to an economically and environmentally sustainable future
Diploma in Engineering Systems (DES)* The Diploma in Engineering Systems course aims to provide students with a broad-based engineering education to support activities and future challenges requiring interdisciplinary engineering systems capabilities
The course leverages on the experience and expertise of two schools, namely the School of Electrical & Electronic Engineering and the School of Mechanical & Aeronautical Engineering
Diploma in Engineering with Business (DEB) Diploma in Engineering with Business provides students with the requisite knowledge and skills in engineering principles, technologies, and business fundamentals, supported by a strong grounding in mathematics and communication skills, which is greatly valued in the rapidly changing industrial and commercial environment
Common Engineering Program (DCEP) In Common Engineering Program, students will get a flavour of electrical, electronic and mechanical engineering in the first semester of their study
They will then choose one of the 7 engineering courses specially selected from the Schools of Electrical & Electronic Engineering and Mechanical & Aeronautical Engineering.  *Course is applicable only for AY2018 intake and earlier School of Electrical & Electronic Engineering More than 60 Years of solid foundation 8 Tech Hubs Unique PTN Scheme  More than 35,000+ Alumni  SP-NUS SP-SUTD Programmes        Electives offered by                                   Electives Choices for All SP students Mod Code  Module Title EP0400 EP0401 EP0402 EP0403 EP0404 EP0405 EP0406 EP0407 EP0408 Unmanned Aircraft Flying and Drone Technologies Python Programming for IoT* Fundamentals of IoT* Creating an IoT Project* AWS Cloud Foundations AWS Academy Cloud Architecting Fundamentals of Intelligent Digital Solutions Technology to Business Cybersecurity Essentials  Certificate in IoT (Internet of Things) * A certificate in IoT would be awarded if a student completes the 3 modules: EP0401, EP0402 and EP0403 Commercial Pilot Theory Autonomous Electric Vehicle Design Artificial Intelligence for Autonomous Vehicle Autonomous Mobile Robots Smart Sensors and Actuators Digital Manufacturing Technology Linux Essential Advanced Linux Linux System Administration Rapid Transit System Rapid Transit Signalling System Data Analytics Electives Choices for EEE students Mod Code  Module Title EM0400 EM0401 EM0402 EM0403 EM0404 EM0405 EM0406 EM0407 EM0408 EM0409 EM0410 EM0412 EM0413  Mobile App Development EM0414 EM0415  Machine Learning & Artificial Intelligence EM0416 EM0417 EM0418 EM0419 EM0423 Solar Photovoltaic System Design Introduction to Energy Efficiency Integrated Building Energy Management System Digital Solutioning Skills Independent Study 1 Client‐Server App Development
